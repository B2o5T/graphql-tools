(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[6161],{5318:function(e,t,r){"use strict";r.d(t,{Zo:function(){return u},kt:function(){return d}});var n=r(7378);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=l(r),d=o,m=h["".concat(c,".").concat(d)]||h[d]||p[d]||a;return r?n.createElement(m,s(s({ref:t},u),{},{components:r})):n.createElement(m,s({ref:t},u))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},2207:function(e,t,r){"use strict";r.r(t),r.d(t,{frontMatter:function(){return i},metadata:function(){return c},toc:function(){return l},default:function(){return p}});var n=r(9603),o=r(120),a=(r(7378),r(5318)),s=["components"],i={id:"connectors",title:"Data fetching",description:"How to fetch data from your GraphQL resolvers."},c={unversionedId:"connectors",id:"connectors",isDocsHomePage:!1,title:"Data fetching",description:"How to fetch data from your GraphQL resolvers.",source:"@site/docs/connectors.md",sourceDirName:".",slug:"/connectors",permalink:"/docs/connectors",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/connectors.md",version:"current",frontMatter:{id:"connectors",title:"Data fetching",description:"How to fetch data from your GraphQL resolvers."},sidebar:"someSidebar",previous:{title:"Mocking",permalink:"/docs/mocking"},next:{title:"Schema directives",permalink:"/docs/schema-directives"}},l=[{value:"Basic fetching",id:"basic-fetching",children:[]},{value:"Factoring out fetching details",id:"factoring-out-fetching-details",children:[]},{value:"DataLoader and caching",id:"dataloader-and-caching",children:[{value:"One dataloader per request",id:"one-dataloader-per-request",children:[]}]}],u={toc:l};function p(e){var t=e.components,r=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"By this point in the documentation, you know how to generate a GraphQL.js schema from the GraphQL schema language, and how to add resolvers to that schema to call functions. How do you access your backend from those resolvers? Well, it's quite easy, but as your app gets more complex it might make sense to add some structure. We'll start with the basics and then move on to more advanced conventions."),(0,a.kt)("h2",{id:"basic-fetching"},"Basic fetching"),(0,a.kt)("p",null,"As you have read on the ",(0,a.kt)("a",{parentName:"p",href:"/docs/resolvers/#resolver-result-format"},"resolvers page"),", resolvers in GraphQL.js can return Promises. This means it's easy to fetch data using any library that returns a promise for the result:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { fetch } from 'cross-fetch';\n\nconst resolverMap = {\n  Query: {\n    async gitHubRepository(root, args, context) {\n      const response = await fetch(`https://api.github.com/repos/${args.name}`);\n      return response.json();\n    }\n  }\n}\n")),(0,a.kt)("h2",{id:"factoring-out-fetching-details"},"Factoring out fetching details"),(0,a.kt)("p",null,'As you start to have more different resolvers that need to access the GitHub API, the above approach becomes unsustainable. It\'s good to abstract that away into a "repository" pattern. We call these data fetching functions "connectors":'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// github-connector.js\nimport { fetch } from 'cross-fetch';\n\n// This gives you a place to put GitHub API keys, for example\nconst { GITHUB_API_KEY, GITHUB_API_SECRET } = process.env;\n\nexport function getRepositoryByName(name) {\n  const response = fetch(`https://api.github.com/repos/${name}?GITHUB_API_KEY=${GITHUB_API_KEY}&GITHUB_API_SECRET=${GITHUB_API_SECRET}`);\n}\n")),(0,a.kt)("p",null,"Now, we can use this function in several resolvers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { getRepositoryByName } from './github-connector.js';\n\nconst resolverMap = {\n  Query: {\n    gitHubRepository(root, args, context) {\n      return getRepositoryByName(args.name);\n    }\n  },\n  Submission: {\n    repository(root, args, context) {\n      return getRepositoryByName(root.repositoryFullName);\n    }\n  }\n}\n")),(0,a.kt)("p",null,"This means we no longer have to worry about the details of fetching from GitHub inside our resolvers, and we just need to put in the right repository name to fetch. We can improve our GitHub fetching logic over time."),(0,a.kt)("h2",{id:"dataloader-and-caching"},"DataLoader and caching"),(0,a.kt)("p",null,"At some point, you might get to a situation where you are fetching the same objects over and over during the course of a single query. For example, you could have a list of repositories which each want to know about their owner:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"query {\n  repositories(limit: 10) {\n    owner {\n      login\n      avatar_url\n    }\n  }\n}\n")),(0,a.kt)("p",null,"Let's say this is our resolver for ",(0,a.kt)("inlineCode",{parentName:"p"},"owner"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { getAuthorByName } from './github-connector.js';\n\nconst resolverMap = {\n  Repository: {\n    owner(root, args, context) {\n      return getAuthorByName(root.owner);\n    },\n  },\n};\n")),(0,a.kt)("p",null,"If the list of repositories has several that were owned by the same user, the ",(0,a.kt)("inlineCode",{parentName:"p"},"getAuthorByName")," function will be called once for each, doing unnecessary requests to the GitHub API, and running down our API limit."),(0,a.kt)("p",null,"You can improve the situation by adding a per-request cache with ",(0,a.kt)("inlineCode",{parentName:"p"},"dataloader"),", Facebook's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/dataloader"},"helpful JavaScript library")," for in-memory data caching."),(0,a.kt)("h3",{id:"one-dataloader-per-request"},"One dataloader per request"),(0,a.kt)("p",null,"One important thing to understand about ",(0,a.kt)("inlineCode",{parentName:"p"},"dataloader")," is that it caches the results forever, unless told otherwise. So we really want to make sure we create a new instance for ",(0,a.kt)("em",{parentName:"p"},"every")," request sent to our server, so that we de-duplicate fetches in one query but not across multiple requests or, even worse, multiple users."))}p.isMDXComponent=!0}}]);