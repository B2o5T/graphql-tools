(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[8564],{5318:function(e,n,t){"use strict";t.d(n,{Zo:function(){return l},kt:function(){return u}});var a=t(7378);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),c=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},l=function(e){var n=c(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=c(t),u=i,h=m["".concat(p,".").concat(u)]||m[u]||d[u]||r;return t?a.createElement(h,o(o({ref:n},l),{},{components:t})):a.createElement(h,o({ref:n},l))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},207:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var a=t(9603),i=t(120),r=(t(7378),t(5318)),o=["components"],s={id:"schema-directives",title:"Schema directives",description:"Using and implementing custom directives to transform schema types, fields, and arguments"},p={unversionedId:"schema-directives",id:"schema-directives",isDocsHomePage:!1,title:"Schema directives",description:"Using and implementing custom directives to transform schema types, fields, and arguments",source:"@site/docs/schema-directives.md",sourceDirName:".",slug:"/schema-directives",permalink:"/docs/schema-directives",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/schema-directives.md",version:"current",frontMatter:{id:"schema-directives",title:"Schema directives",description:"Using and implementing custom directives to transform schema types, fields, and arguments"},sidebar:"someSidebar",previous:{title:"Data fetching",permalink:"/docs/connectors"},next:{title:"Directive resolvers",permalink:"/docs/directive-resolvers"}},c=[{value:"(At least) two strategies",id:"at-least-two-strategies",children:[]},{value:"Using schema directives",id:"using-schema-directives",children:[]},{value:"Implementing schema directives",id:"implementing-schema-directives",children:[]},{value:"Examples",id:"examples",children:[{value:"Uppercasing strings",id:"uppercasing-strings",children:[]},{value:"Fetching data from a REST API",id:"fetching-data-from-a-rest-api",children:[]},{value:"Formatting date strings",id:"formatting-date-strings",children:[]},{value:"Enforcing access permissions",id:"enforcing-access-permissions",children:[]},{value:"Enforcing value restrictions",id:"enforcing-value-restrictions",children:[]},{value:"Synthesizing unique IDs",id:"synthesizing-unique-ids",children:[]}]},{value:"Declaring schema directives",id:"declaring-schema-directives",children:[]},{value:"What about query directives?",id:"what-about-query-directives",children:[]},{value:"What about <code>directiveResolvers</code>?",id:"what-about-directiveresolvers",children:[]},{value:"What about code-first schemas?",id:"what-about-code-first-schemas",children:[]},{value:"Full mapSchema API",id:"full-mapschema-api",children:[]}],l={toc:c};function d(e){var n=e.components,t=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"directive")," is an identifier preceded by a ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," character, optionally followed by a list of named arguments, which can appear after almost any form of syntax in the GraphQL query or schema languages. Here's an example from the ",(0,r.kt)("a",{parentName:"p",href:"http://facebook.github.io/graphql/draft/#sec-Type-System.Directives"},"GraphQL draft specification")," that illustrates several of these possibilities:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'directive @deprecated(\n  reason: String = "No longer supported"\n) on FIELD_DEFINITION | ENUM_VALUE\n\ntype ExampleType {\n  newField: String\n  oldField: String @deprecated(reason: "Use `newField`.")\n}\n')),(0,r.kt)("p",null,"As you can see, the usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated(reason: ...)")," ",(0,r.kt)("em",{parentName:"p"},"follows")," the field that it pertains to (",(0,r.kt)("inlineCode",{parentName:"p"},"oldField"),'), though the syntax might remind you of "decorators" in other languages, which usually appear on the line above. Directives are typically ',(0,r.kt)("em",{parentName:"p"},"declared")," once, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"directive @deprecated ... on ...")," syntax, and then ",(0,r.kt)("em",{parentName:"p"},"used")," zero or more times throughout the schema document, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated(reason: ...)")," syntax."),(0,r.kt)("p",null,"The possible applications of directive syntax are numerous: enforcing access permissions, formatting date strings, auto-generating resolver functions for a particular backend API, marking strings for internationalization, synthesizing globally unique object identifiers, specifying caching behavior, skipping or including or deprecating fields, and just about anything else you can imagine."),(0,r.kt)("p",null,"This document focuses on directives that appear in GraphQL ",(0,r.kt)("em",{parentName:"p"},"schemas")," (as opposed to queries) written in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/graphql/pull/90"},"Schema Definition Language"),", or SDL for short. In the following sections, you will see how custom directives can be implemented and used to modify the structure and behavior of a GraphQL schema in ways that would not be possible using SDL syntax alone."),(0,r.kt)("h2",{id:"at-least-two-strategies"},"(At least) two strategies"),(0,r.kt)("p",null,"Earlier versions of ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-tools")," provides a class-based mechanism for directive-based schema modification. The documentation for the class-based version is ",(0,r.kt)("a",{parentName:"p",href:"/docs/legacy-schema-directives/"},"still available"),", but the remainder of this document describes the newer functional mechanism. We believe the newer approach is easier to reason about, but older class-based schema directives are still supported."),(0,r.kt)("h2",{id:"using-schema-directives"},"Using schema directives"),(0,r.kt)("p",null,"Most of this document is concerned with ",(0,r.kt)("em",{parentName:"p"},"implementing")," schema directives, and some of the examples may seem quite complicated. No matter how many tools and best practices you have at your disposal, it can be difficult to implement a non-trivial schema directive in a reliable, reusable way. Exhaustive testing is essential, and using a typed language like TypeScript is recommended, because there are so many different schema types to worry about."),(0,r.kt)("p",null,"However, the API we provide for ",(0,r.kt)("em",{parentName:"p"},"using")," a schema directive is extremely simple. Just import the implementation of the directive, then pass it to ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema")," via the ",(0,r.kt)("inlineCode",{parentName:"p"},"schemaTransforms")," argument, which is an array of schema transformation functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { makeExecutableSchema } from '@graphql-tools/schema';\nimport { renameDirective } from 'fake-rename-directive-package';\n\nconst typeDefs = `\ntype Person @rename(to: \"Human\") {\n  name: String!\n  currentDateMinusDateOfBirth: Int @rename(to: \"age\")\n}`;\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaTransforms: [renameDirective('rename')],\n});\n")),(0,r.kt)("p",null,"That's it. The implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"renameDirective")," takes care of everything else. If you understand what the directive is supposed to do to your schema, then you do not have to worry about how it works."),(0,r.kt)("p",null,"Everything you read below addresses some aspect of how a directive like ",(0,r.kt)("inlineCode",{parentName:"p"},"@rename(to: ...)")," could be implemented. If that's not something you care about right now, feel free to skip the rest of this document. When you need it, it will be here."),(0,r.kt)("h2",{id:"implementing-schema-directives"},"Implementing schema directives"),(0,r.kt)("p",null,"Since the GraphQL specification does not discuss any specific implementation strategy for directives, it's up to each GraphQL server framework to expose an API for implementing new directives."),(0,r.kt)("p",null,"GraphQL Tools provides convenient yet powerful tools for implementing directive syntax: the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ardatan/graphql-tools/blob/master/packages/utils/src/mapSchema.ts"},(0,r.kt)("inlineCode",{parentName:"a"},"mapSchema"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ardatan/graphql-tools/blob/schemaTransforms/packages/utils/src/get-directives.ts"},(0,r.kt)("inlineCode",{parentName:"a"},"getDirectives"))," functions. ",(0,r.kt)("inlineCode",{parentName:"p"},"mapSchema")," takes two arguments: the original schema, and an object map -- pardon the pun -- of functions that can be used to transform each GraphQL object within the original schema. ",(0,r.kt)("inlineCode",{parentName:"p"},"mapSchema")," is a powerful tool, in that it creates a new copy of the original schema, transforms GraphQL objects as specified, and then rewires the entire schema such that all GraphQL objects that refer to other GraphQL objects correctly point to the new set. The ",(0,r.kt)("inlineCode",{parentName:"p"},"getDirectives")," function is straightforward; it extracts any directives (with their arguments) from the SDL originally used to create any GraphQL object."),(0,r.kt)("p",null,"Here is one possible implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated")," directive we saw above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { mapSchema, getDirectives } from '@graphql-tools/utils';\nimport { GraphQLSchema } from 'graphql';\n\nexport function deprecatedDirective(directiveName: string) {\n  return {\n    deprecatedDirectiveTypeDefs: `directive @${directiveName}(reason: String) on FIELD_DEFINITION | ENUM_VALUE`,\n    deprecatedDirectiveTransformer: (schema: GraphQLSchema) =>\n      mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: fieldConfig => {\n          const directives = getDirectives(schema, fieldConfig);\n          const directiveArgumentMap = directives[directiveName];\n          if (directiveArgumentMap) {\n            fieldConfig.deprecationReason = directiveArgumentMap.reason;\n            return fieldConfig;\n          }\n        },\n        [MapperKind.ENUM_VALUE]: enumValueConfig => {\n          const directives = getDirectives(schema, enumValueConfig);\n          const directiveArgumentMap = directives[directiveName];\n          if (directiveArgumentMap) {\n            enumValueConfig.deprecationReason = directiveArgumentMap.reason;\n            return enumValueConfig;\n          }\n        },\n      }),\n  };\n}\n")),(0,r.kt)("p",null,"In order to apply this implementation to a schema that contains ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated")," directives, simply pass the necessary typeDefs and schema transformation function to the ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema")," function in the appropriate positions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { deprecatedDirective } from 'fake-deprecated-directive-package';\nimport { makeExecutableSchema } from '@graphql-tools/schema';\n\nconst { deprecatedDirectiveTypeDefs, deprecatedDirectiveTransformer } = deprecatedDirective('deprecated');\n\nconst schema = makeExecutableSchema({\n  typeDefs: [\n    deprecatedDirectiveTypeDefs,\n    `\n    type ExampleType {\n      newField: String\n      oldField: String @deprecated(reason: \"Use \\`newField\\`.\")\n    }\n\n    type Query {\n      rootField: ExampleType\n    }\n  `,\n  ],\n  schemaTransforms: [deprecatedDirectiveTransformer],\n});\n")),(0,r.kt)("p",null,"Alternatively, if you want to modify an existing schema object, you can use the function interface directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const schemaTransform = deprecatedDirective('deprecated');\nconst newSchema = schemaTransform(originalSchema);\n")),(0,r.kt)("p",null,"We suggest that creators of directive-based schema modification functions allow users to customize the names of the relevant directives, to help users avoid collision of directive names with existing directives within their schema or other external schema modification functions. Of course, you could hard-code the name of the directive into the function, further simplifying the above examples."),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"To appreciate the range of possibilities enabled by ",(0,r.kt)("inlineCode",{parentName:"p"},"mapSchema"),", let's examine a variety of practical examples."),(0,r.kt)("h3",{id:"uppercasing-strings"},"Uppercasing strings"),(0,r.kt)("p",null,"Suppose you want to ensure a string-valued field is converted to uppercase. Though this use case is simple, it's a good example of a directive implementation that works by wrapping a field's ",(0,r.kt)("inlineCode",{parentName:"p"},"resolve")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function upperDirective(directiveName: string) {\n  return {\n    upperDirectiveTypeDefs: `directive @${directiveName} on FIELD_DEFINITION`,\n    upperDirectiveTransformer: (schema: GraphQLSchema) => mapSchema(schema, {\n      [MapperKind.OBJECT_FIELD]: (fieldConfig) => {\n        const directives = getDirectives(schema, fieldConfig);\n        if (directives[directiveName]) {\n          const { resolve = defaultFieldResolver } = fieldConfig;\n          fieldConfig.resolve = async function (source, args, context, info) {\n            const result = await resolve(source, args, context, info);\n            if (typeof result === 'string') {\n              return result.toUpperCase();\n            }\n            return result;\n          }\n          return fieldConfig;\n        }\n      }\n    })\n  };\n}\n\nconst { upperDirectiveTypeDefs, upperDirectiveTransformer } = upperDirective('upper');\nconst { upperDirectiveTypeDefs: upperCaseDirectiveTypeDefs, upperDirectiveTransformer:upperCaseDirectiveTransformer } = upperDirective('upperCase');\n\nconst schema = makeExecutableSchema({\n  typeDefs: [upperDirectiveTypeDefs, upperCaseDirectiveTypeDefs, `\n    type Query {\n      hello: String @upper\n      hello2: String @upperCase\n    }\n  `],\n  resolvers: {\n    Query: {\n      hello() {\n        return 'hello world';\n      },\n      hello2() {\n        return 'hello world';\n      },\n    },\n  },\n  schemaTransforms: [upperDirectiveTransformer, upperCaseDirectiveTransformer],\n});\n});\n")),(0,r.kt)("p",null,"Notice how easy it is to handle both ",(0,r.kt)("inlineCode",{parentName:"p"},"@upper")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@upperCase")," with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"upperDirective")," implementation."),(0,r.kt)("h3",{id:"fetching-data-from-a-rest-api"},"Fetching data from a REST API"),(0,r.kt)("p",null,"Suppose you've defined an object type that corresponds to a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Representational_state_transfer"},"REST")," resource, and you want to avoid implementing resolver functions for every field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function restDirective(directiveName: string) {\n  return {\n    restDirectiveTypeDefs: `directive @${directiveName}(url: String) on FIELD_DEFINITION`;\n    restDirectiveTransformer: (schema: GraphQLSchema) => mapSchema(schema, {\n      [MapperKind.OBJECT_FIELD]: (fieldConfig) => {\n        const directives = getDirectives(schema, fieldConfig);\n        const directiveArgumentMap = directives[directiveName];\n        if (directiveArgumentMap) {\n          const { url } = directiveArgumentMap;\n          fieldConfig.resolve = () => fetch(url);\n          return fieldConfig;\n        }\n      }\n    },\n  });\n}\n\nconst { restDirectiveTypeDefs, restDirectiveTransformer } = restDirective('rest');\n\nconst schema = makeExecutableSchema({\n  typeDefs: [restDirectiveTypeDefs, `\n    type Query {\n      people: [Person] @rest(url: \"/api/v1/people\")\n    }\n  `],\n  schemaTransforms: [restDirectiveTransformer],\n});\n")),(0,r.kt)("p",null,"There are many more issues to consider when implementing a real GraphQL wrapper over a REST endpoint (such as how to do caching or pagination), but this example demonstrates the basic structure."),(0,r.kt)("h3",{id:"formatting-date-strings"},"Formatting date strings"),(0,r.kt)("p",null,"Suppose your resolver returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," object but you want to return a formatted string to the client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function dateDirective(directiveName: string) {\n  return {\n    dateDirectiveTypeDefs: `directive @${directiveName}(format: String) on FIELD_DEFINITION`,\n    dateDirectiveTransformer: (schema: GraphQLSchema) =>\n      mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: fieldConfig => {\n          const directives = getDirectives(schema, fieldConfig);\n          const directiveArgumentMap = directives[directiveName];\n          if (directiveArgumentMap) {\n            const { resolve = defaultFieldResolver } = fieldConfig;\n            const { format } = directiveArgumentMap;\n            fieldConfig.resolve = async function (source, args, context, info) {\n              const date = await resolve(source, args, context, info);\n              return formatDate(date, format, true);\n            };\n            return fieldConfig;\n          }\n        },\n      }),\n  };\n}\n\nconst { dateDirectiveTypeDefs, dateDirectiveTransformer } = dateDirective('date');\n\nconst schema = makeExecutableSchema({\n  typeDefs: [\n    dateDirectiveTypeDefs,\n    `\n    scalar Date\n\n    type Query {\n      today: Date @date(format: \"mmmm d, yyyy\")\n    }\n  `,\n  ],\n  resolvers: {\n    Query: {\n      today() {\n        return new Date(1519688273858).toUTCString();\n      },\n    },\n  },\n  schemaTransforms: [dateDirectiveTransformer],\n});\n")),(0,r.kt)("p",null,"Of course, it would be even better if the schema author did not have to decide on a specific ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," format, but could instead leave that decision to the client. To make this work, the directive just needs to add an additional argument to the field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import formatDate from 'dateformat';\n\nfunction formattableDateDirective(directiveName: string) {\n  return {\n    formattableDateDirectiveTypeDefs: `directive @${directiveName}(\n        defaultFormat: String = \"mmmm d, yyyy\"\n      ) on FIELD_DEFINITION\n    `,\n    formattableDateDirectiveTransformer: (schema: GraphQLSchema) =>\n      mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: fieldConfig => {\n          const directives = getDirectives(schema, fieldConfig);\n          const directiveArgumentMap = directives[directiveName];\n          if (directiveArgumentMap) {\n            const { resolve = defaultFieldResolver } = fieldConfig;\n            const { defaultFormat } = directiveArgumentMap;\n\n            fieldConfig.args['format'] = {\n              type: GraphQLString,\n            };\n\n            fieldConfig.type = GraphQLString;\n            fieldConfig.resolve = async function (source, { format, ...args }, context, info) {\n              const newFormat = format || defaultFormat;\n              const date = await resolve(source, args, context, info);\n              return formatDate(date, newFormat, true);\n            };\n            return fieldConfig;\n          }\n        },\n      }),\n  };\n}\n\nconst { formattableDateDirectiveTypeDefs, formattableDateDirectiveTransformer } = formattableDateDirective('date');\n\nconst schema = makeExecutableSchema({\n  typeDefs: [\n    formattableDateDirectiveTypeDefs,\n    `\n    scalar Date\n\n    type Query {\n      today: Date @date\n    }\n  `,\n  ],\n  resolvers: {\n    Query: {\n      today() {\n        return new Date(1521131357195);\n      },\n    },\n  },\n  schemaTransforms: [formattableDateDirectiveTransformer],\n});\n")),(0,r.kt)("p",null,"Now the client can specify a desired ",(0,r.kt)("inlineCode",{parentName:"p"},"format")," argument when requesting the ",(0,r.kt)("inlineCode",{parentName:"p"},"Query.today")," field, or omit the argument to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"defaultFormat")," string specified in the schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { graphql } from \'graphql\';\n\ngraphql(\n  schema,\n  `\n    query {\n      today\n    }\n  `\n).then(result => {\n  // Logs with the default "mmmm d, yyyy" format:\n  console.log(result.data.today);\n});\n\ngraphql(\n  schema,\n  `\n    query {\n      today(format: "d mmm yyyy")\n    }\n  `\n).then(result => {\n  // Logs with the requested "d mmm yyyy" format:\n  console.log(result.data.today);\n});\n')),(0,r.kt)("h3",{id:"enforcing-access-permissions"},"Enforcing access permissions"),(0,r.kt)("p",null,"Imagine a hypothetical ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," directive that takes an argument ",(0,r.kt)("inlineCode",{parentName:"p"},"requires")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Role"),", which defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"ADMIN"),". This ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," directive can appear on an ",(0,r.kt)("inlineCode",{parentName:"p"},"OBJECT")," like ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," to set default access permissions for all ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," fields, as well as appearing on individual fields, to enforce field-specific ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," restrictions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @auth(requires: Role = ADMIN) on OBJECT | FIELD_DEFINITION\n\nenum Role {\n  ADMIN\n  REVIEWER\n  USER\n  UNKNOWN\n}\n\ntype User @auth(requires: USER) {\n  name: String\n  banned: Boolean @auth(requires: ADMIN)\n  canPost: Boolean @auth(requires: REVIEWER)\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function authDirective(directiveName: string, getUserFn: (token: string) => { hasRole: (role: string) => boolean} ) {\n  const typeDirectiveArgumentMaps: Record<string, any> = {};\n  return {\n    authDirectiveTypeDefs: `directive @${directiveName}(\n      requires: Role = ADMIN,\n    ) on OBJECT | FIELD_DEFINITION\n\n    enum Role {\n      ADMIN\n      REVIEWER\n      USER\n      UNKNOWN\n    }`,\n    authDirectiveTransformer: (schema: GraphQLSchema) => mapSchema(schema, {\n      [MapperKind.TYPE]: (type) => {\n        const typeDirectives = getDirectives(schema, type);\n        typeDirectiveArgumentMaps[type.name] = typeDirectives[directiveName];\n        return undefined;\n      },\n      [MapperKind.OBJECT_FIELD]: (fieldConfig, _fieldName, typeName) => {\n        const fieldDirectives = getDirectives(schema, fieldConfig);\n        const directiveArgumentMap = fieldDirectives[directiveName] ?? typeDirectiveArgumentMaps[typeName];\n        if (directiveArgumentMap) {\n          const { requires } = directiveArgumentMap;\n          if (requires) {\n            const { resolve = defaultFieldResolver } = fieldConfig;\n            fieldConfig.resolve = function (source, args, context, info) {\n              const user = getUserFn(context.headers.authToken);\n              if (!user.hasRole(requires)) {\n                throw new Error('not authorized');\n              }\n              return resolve(source, args, context, info);\n            }\n            return fieldConfig;\n          }\n        }\n      }\n    })\n  };\n};\n\nfunction getUser(token: string) {\n  const roles = ['UNKNOWN', 'USER', 'REVIEWER', 'ADMIN'];\n  return {\n    hasRole: (role: string) => {\n      const tokenIndex = roles.indexOf(token);\n      const roleIndex = roles.indexOf(role);\n      return roleIndex >= 0 && tokenIndex >= roleIndex;\n    },\n  };\n}\n\nconst { authDirectiveTypeDefs, authDirectiveTransformer } = authDirective('auth', getUser);\n\nconst schema = makeExecutableSchema({\n  typeDefs: [authDirectiveTypeDefs, `\n    type User @auth(requires: USER) {\n      name: String\n      banned: Boolean @auth(requires: ADMIN)\n      canPost: Boolean @auth(requires: REVIEWER)\n    }\n\n    type Query {\n      users: [User]\n    }\n  `],\n  resolvers: {\n    Query: {\n      users() {\n        return [\n          {\n            banned: true,\n            canPost: false,\n            name: 'Ben',\n          },\n        ];\n      },\n    },\n  },\n  schemaTransforms: [authDirectiveTransformer],\n});\n});\n")),(0,r.kt)("p",null,"One drawback of this approach is that it does not guarantee fields will be wrapped if they are added to the schema after ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthDirective")," is applied, and the whole ",(0,r.kt)("inlineCode",{parentName:"p"},"getUser(context.headers.authToken)")," is a made-up API that would need to be fleshed out. In other words, we\u2019ve glossed over some of the details that would be required for a production-ready implementation of this directive, though we hope the basic structure shown here inspires you to find clever solutions to the remaining problems."),(0,r.kt)("h3",{id:"enforcing-value-restrictions"},"Enforcing value restrictions"),(0,r.kt)("p",null,"Suppose you want to enforce a maximum length for a string-valued field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function lengthDirective(directiveName: string) {\n  class LimitedLengthType extends GraphQLScalarType {\n    constructor(type: GraphQLScalarType, maxLength: number) {\n      super({\n        name: `${type.name}WithLengthAtMost${maxLength.toString()}`,\n\n        serialize(value: string) {\n          const newValue: string = type.serialize(value);\n          expect(typeof newValue.length).toBe('number');\n          if (newValue.length > maxLength) {\n            throw new Error(\n              `expected ${newValue.length.toString(\n                10,\n              )} to be at most ${maxLength.toString(10)}`,\n            );\n          }\n          return newValue;\n        },\n\n        parseValue(value: string) {\n          return type.parseValue(value);\n        },\n\n        parseLiteral(ast: StringValueNode) {\n          return type.parseLiteral(ast, {});\n        },\n      });\n    }\n  }\n\n  const limitedLengthTypes: Record<string, Record<number, GraphQLScalarType>> = {};\n\n  function getLimitedLengthType(type: GraphQLScalarType, maxLength: number): GraphQLScalarType {\n    const limitedLengthTypesByTypeName = limitedLengthTypes[type.name]\n    if (!limitedLengthTypesByTypeName) {\n      const newType = new LimitedLengthType(type, maxLength);\n      limitedLengthTypes[type.name] = {}\n      limitedLengthTypes[type.name][maxLength] = newType;\n      return newType;\n    }\n\n    const limitedLengthType = limitedLengthTypesByTypeName[maxLength];\n    if (!limitedLengthType) {\n      const newType = new LimitedLengthType(type, maxLength);\n      limitedLengthTypesByTypeName[maxLength] = newType;\n      return newType;\n    }\n\n    return limitedLengthType;\n  }\n\n  function wrapType<F extends GraphQLFieldConfig<any, any> | GraphQLInputFieldConfig>(fieldConfig: F, directiveArgumentMap: Record<string, any>): void {\n    if (isNonNullType(fieldConfig.type) && isScalarType(fieldConfig.type.ofType)) {\n      fieldConfig.type = getLimitedLengthType(fieldConfig.type.ofType, directiveArgumentMap.max);\n    } else if (isScalarType(fieldConfig.type)) {\n      fieldConfig.type = getLimitedLengthType(fieldConfig.type, directiveArgumentMap.max);\n    } else {\n      throw new Error(`Not a scalar type: ${fieldConfig.type.toString()}`);\n    }\n  }\n\n  return {\n    lengthDirectiveTypeDefs: `directive @${directiveName}(max: Int) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION`,\n    lengthDirectiveTransformer: (schema: GraphQLSchema) => mapSchema(schema, {\n      [MapperKind.FIELD]: (fieldConfig) => {\n        const directives = getDirectives(schema, fieldConfig);\n        const directiveArgumentMap = directives[directiveName];\n        if (directiveArgumentMap) {\n          wrapType(fieldConfig, directiveArgumentMap);\n          return fieldConfig;\n        }\n      }\n    }),\n  };\n};\n\nconst { lengthDirectiveTypeDefs, lengthDirectiveTransformer } = lengthDirective('length');\n\nconst schema = makeExecutableSchema({\n  typeDefs: [lengthDirectiveTypeDefs, `\n    type Query {\n      books: [Book]\n    }\n\n    type Book {\n      title: String @length(max: 10)\n    }\n\n    type Mutation {\n      createBook(book: BookInput): Book\n    }\n\n    input BookInput {\n      title: String! @length(max: 10)\n    }`]\n  ,\n  resolvers: {\n    Query: {\n      books() {\n        return [\n          {\n            title: 'abcdefghijklmnopqrstuvwxyz',\n          },\n        ];\n      },\n    },\n    Mutation: {\n      createBook(_parent, args) {\n        return args.book;\n      },\n    },\n  },\n  schemaTransforms: [lengthDirectiveTransformer],\n});\n")),(0,r.kt)("p",null,"Note that new types can be added to the schema with ease, but that each type must be uniquely named."),(0,r.kt)("h3",{id:"synthesizing-unique-ids"},"Synthesizing unique IDs"),(0,r.kt)("p",null,"Suppose your database uses incrementing IDs for each resource type, so IDs are not unique across all resource types. Here\u2019s how you might synthesize a field called ",(0,r.kt)("inlineCode",{parentName:"p"},"uid")," that combines the object type with various field values to produce an ID that\u2019s unique across your schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { GraphQLID } from 'graphql';\nimport { createHash } from 'crypto';\n\nfunction uniqueIDDirective(directiveName: string) {\n  return {\n    uniqueIDDirectiveTypeDefs: `directive @${directiveName}(name: String, from: [String]) on OBJECT`,\n    uniqueIDDirectiveTransformer: (schema: GraphQLSchema) =>\n      mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n          const directives = getDirectives(schema, type);\n          const directiveArgumentMap = directives[directiveName];\n          if (directiveArgumentMap) {\n            const { name, from } = directiveArgumentMap;\n            const config = type.toConfig();\n            config.fields[name] = {\n              type: GraphQLID,\n              description: 'Unique ID',\n              args: {},\n              resolve(object: any) {\n                const hash = createHash('sha1');\n                hash.update(type.name);\n                from.forEach((fieldName: string) => {\n                  hash.update(String(object[fieldName]));\n                });\n                return hash.digest('hex');\n              },\n            };\n            return new GraphQLObjectType(config);\n          }\n        },\n      }),\n  };\n}\n\nconst { uniqueIDDirectiveTypeDefs, uniqueIDDirectiveTransformer } = uniqueIDDirective('uniqueID');\n\nconst schema = makeExecutableSchema({\n  typeDefs: [\n    uniqueIDDirectiveTypeDefs,\n    `\n    type Query {\n      people: [Person]\n      locations: [Location]\n    }\n\n    type Person @uniqueID(name: \"uid\", from: [\"personID\"]) {\n      personID: Int\n      name: String\n    }\n\n    type Location @uniqueID(name: \"uid\", from: [\"locationID\"]) {\n      locationID: Int\n      address: String\n    }\n  `,\n  ],\n  resolvers: {\n    Query: {\n      people() {\n        return [\n          {\n            personID: 1,\n            name: 'Ben',\n          },\n        ];\n      },\n      locations() {\n        return [\n          {\n            locationID: 1,\n            address: '140 10th St',\n          },\n        ];\n      },\n    },\n  },\n  schemaTransforms: [uniqueIDDirectiveTransformer],\n});\n")),(0,r.kt)("h2",{id:"declaring-schema-directives"},"Declaring schema directives"),(0,r.kt)("p",null,"SDL syntax requires declaring the names, argument types, default argument values, and permissible locations of any available directives. We have shown one approach above to doing so. If you're implementing a reusable directive for public consumption, you will probably want to either guide your users as to how properly declare their directives, or export the required SDL syntax as above so that users can pass it to ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema"),". These techniques can be used in combination, i.e. you may wish to export the directive syntax and provide instructions on how to structure any dependent types. Take a second look at the auth example above to see how this may be done and note the interplay between the directive definition and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Role")," type."),(0,r.kt)("h2",{id:"what-about-query-directives"},"What about query directives?"),(0,r.kt)("p",null,"Directive syntax can also appear in GraphQL queries sent from the client. Query directive implementation can be performed within graphql resolver using similar techniques as the above. In general, however, schema authors should consider using field arguments wherever possible instead of query directives, with query directives most useful for annotating the query with metadata affecting the execution algorithm itself, e.g. ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-spec/blob/master/rfcs/DeferStream.md"},(0,r.kt)("inlineCode",{parentName:"a"},"defer"),", ",(0,r.kt)("inlineCode",{parentName:"a"},"stream")),", etc."),(0,r.kt)("p",null,"In theory, access to the query directives is available within the ",(0,r.kt)("inlineCode",{parentName:"p"},"info")," resolver argument by iterating through each ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldNode")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"info.fieldNodes"),", although, as above, use of query directives within standard resolvers is not necessarily recommended."),(0,r.kt)("h2",{id:"what-about-directiveresolvers"},"What about ",(0,r.kt)("inlineCode",{parentName:"h2"},"directiveResolvers"),"?"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema")," function also takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"directiveResolvers")," option that can be used for implementing certain kinds of ",(0,r.kt)("inlineCode",{parentName:"p"},"@directive"),"s on fields that have resolver functions."),(0,r.kt)("p",null,"The new abstraction is more general, since it can visit any kind of schema syntax, and do much more than just wrap resolver functions. However, the old ",(0,r.kt)("inlineCode",{parentName:"p"},"directiveResolvers")," API has been ",(0,r.kt)("a",{parentName:"p",href:"directive-resolvers"},"left in place")," for backwards compatibility, though it is now implemented in terms of ",(0,r.kt)("inlineCode",{parentName:"p"},"mapSchema"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export function attachDirectiveResolvers(\n  schema: GraphQLSchema,\n  directiveResolvers: IDirectiveResolvers\n): GraphQLSchema {\n  // ... argument validation ...\n\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_FIELD]: fieldConfig => {\n      const newFieldConfig = { ...fieldConfig };\n\n      const directives = getDirectives(schema, fieldConfig);\n      Object.keys(directives).forEach(directiveName => {\n        if (directiveResolvers[directiveName]) {\n          const resolver = directiveResolvers[directiveName];\n          const originalResolver = newFieldConfig.resolve != null ? newFieldConfig.resolve : defaultFieldResolver;\n          const directiveArgs = directives[directiveName];\n          newFieldConfig.resolve = (source, originalArgs, context, info) => {\n            return resolver(\n              () =>\n                new Promise((resolve, reject) => {\n                  const result = originalResolver(source, originalArgs, context, info);\n                  if (result instanceof Error) {\n                    reject(result);\n                  }\n                  resolve(result);\n                }),\n              source,\n              directiveArgs,\n              context,\n              info\n            );\n          };\n        }\n      });\n\n      return newFieldConfig;\n    },\n  });\n}\n")),(0,r.kt)("p",null,"Existing code that uses ",(0,r.kt)("inlineCode",{parentName:"p"},"directiveResolvers")," could consider migrating to direct usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"mapSchema"),", though we have no immediate plans to deprecate ",(0,r.kt)("inlineCode",{parentName:"p"},"directiveResolvers"),"."),(0,r.kt)("h2",{id:"what-about-code-first-schemas"},"What about code-first schemas?"),(0,r.kt)("p",null,"You can use schema transformation functions with code-first schemas as well. By default, if a ",(0,r.kt)("inlineCode",{parentName:"p"},"directives")," key exists within the ",(0,r.kt)("inlineCode",{parentName:"p"},"extensions")," field for a given GraphQL entity, the ",(0,r.kt)("inlineCode",{parentName:"p"},"getDirectives")," function will retrieve the directive data from the GraphQL entity's ",(0,r.kt)("inlineCode",{parentName:"p"},"extensions.directives")," data rather than from the SDL. This, of course, allows schemas created without SDL to use any schema transformation functions created for directive use, as long as they define the necessary data within the GraphQL entity extensions."),(0,r.kt)("p",null,"This behavior can be customized! The ",(0,r.kt)("inlineCode",{parentName:"p"},"getDirectives")," function takes a third argument, ",(0,r.kt)("inlineCode",{parentName:"p"},"pathToDirectivesInExtensions"),", an array of strings, that allows customization of this path to directive data within extensions, which is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"['directives']")," by default. We recommend allowing end users to customize this path similar to how the directive name can be customized above."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-js/issues/1343"},"this ",(0,r.kt)("inlineCode",{parentName:"a"},"graphql-js")," issue")," for more information on directives with code-first schemas. We follow the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-js/issues/1343#issuecomment-479877640"},"Gatsby and graphql-compose convention")," of reading directives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"extensions")," field, but allow customization as above."),(0,r.kt)("h2",{id:"full-mapschema-api"},"Full mapSchema API"),(0,r.kt)("p",null,"How can you customize schema mapping? The second argument provided to mapSchema is an object of type ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaMapper")," that can specify individual mapping functions."),(0,r.kt)("p",null,"GraphQL objects are mapped according to the following algorithm:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Types are mapped. The most general matching mapping function available will be used, i.e. inclusion of a ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.TYPE")," will cause all types to be mapped with the specified mapper. Specifying ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.ABSTRACT_TYPE")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.MAPPER.QUERY")," mappers will cause the first mapper to be used for interfaces and unions, the latter to be used for the root query object type, and all other types to be ignored."),(0,r.kt)("li",{parentName:"ol"},"Enum values are mapped. If all you want to do to an enum is to change one value, it is more convenient to use a ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.ENUM_VALUE")," mapper than to iterate through all values on your own and recreate the type -- although that would work!"),(0,r.kt)("li",{parentName:"ol"},"Fields are mapped. Similar to above, if you want to modify a single field, ",(0,r.kt)("inlineCode",{parentName:"li"},"mapSchema")," can do the iteration for you. You can subspecify ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.OBJECT_FIELD")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.ROOT_FIELD")," to select a limited subset of fields to map."),(0,r.kt)("li",{parentName:"ol"},"Arguments are mapped. Similar to above, you can subspecify ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.ARGUMENT")," if you want to modify only an argument. ",(0,r.kt)("inlineCode",{parentName:"li"},"mapSchema")," can iterate through the types and fields for you."),(0,r.kt)("li",{parentName:"ol"},"Directives are mapped if ",(0,r.kt)("inlineCode",{parentName:"li"},"MapperKind.DIRECTIVE")," is specified.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface SchemaMapper {\n  [MapperKind.TYPE]?: NamedTypeMapper;\n  [MapperKind.SCALAR_TYPE]?: ScalarTypeMapper;\n  [MapperKind.ENUM_TYPE]?: EnumTypeMapper;\n  [MapperKind.COMPOSITE_TYPE]?: CompositeTypeMapper;\n  [MapperKind.OBJECT_TYPE]?: ObjectTypeMapper;\n  [MapperKind.INPUT_OBJECT_TYPE]?: InputObjectTypeMapper;\n  [MapperKind.ABSTRACT_TYPE]?: AbstractTypeMapper;\n  [MapperKind.UNION_TYPE]?: UnionTypeMapper;\n  [MapperKind.INTERFACE_TYPE]?: InterfaceTypeMapper;\n  [MapperKind.ROOT_OBJECT]?: ObjectTypeMapper;\n  [MapperKind.QUERY]?: ObjectTypeMapper;\n  [MapperKind.MUTATION]?: ObjectTypeMapper;\n  [MapperKind.SUBSCRIPTION]?: ObjectTypeMapper;\n  [MapperKind.ENUM_VALUE]?: EnumValueMapper;\n  [MapperKind.FIELD]?: GenericFieldMapper<GraphQLFieldConfig<any, any> | GraphQLInputFieldConfig>;\n  [MapperKind.OBJECT_FIELD]?: FieldMapper;\n  [MapperKind.ROOT_FIELD]?: FieldMapper;\n  [MapperKind.QUERY_ROOT_FIELD]?: FieldMapper;\n  [MapperKind.MUTATION_ROOT_FIELD]?: FieldMapper;\n  [MapperKind.SUBSCRIPTION_ROOT_FIELD]?: FieldMapper;\n  [MapperKind.INTERFACE_FIELD]?: FieldMapper;\n  [MapperKind.COMPOSITE_FIELD]?: FieldMapper;\n  [MapperKind.INPUT_OBJECT_FIELD]?: InputFieldMapper;\n  [MapperKind.ARGUMENT]?: ArgumentMapper;\n  [MapperKind.DIRECTIVE]?: DirectiveMapper;\n}\n\nexport type NamedTypeMapper = (type: GraphQLNamedType, schema: GraphQLSchema) => GraphQLNamedType | null | undefined;\n\nexport type ScalarTypeMapper = (type: GraphQLScalarType, schema: GraphQLSchema) => GraphQLScalarType | null | undefined;\n\nexport type EnumTypeMapper = (type: GraphQLEnumType, schema: GraphQLSchema) => GraphQLEnumType | null | undefined;\n\nexport type EnumValueMapper = (\n  value: GraphQLEnumValueConfig,\n  typeName: string,\n  schema: GraphQLSchema\n) => GraphQLEnumValueConfig | [string, GraphQLEnumValueConfig] | null | undefined;\n\nexport type CompositeTypeMapper = (\n  type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema\n) => GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type ObjectTypeMapper = (type: GraphQLObjectType, schema: GraphQLSchema) => GraphQLObjectType | null | undefined;\n\nexport type InputObjectTypeMapper = (\n  type: GraphQLInputObjectType,\n  schema: GraphQLSchema\n) => GraphQLInputObjectType | null | undefined;\n\nexport type AbstractTypeMapper = (\n  type: GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema\n) => GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type UnionTypeMapper = (type: GraphQLUnionType, schema: GraphQLSchema) => GraphQLUnionType | null | undefined;\n\nexport type InterfaceTypeMapper = (\n  type: GraphQLInterfaceType,\n  schema: GraphQLSchema\n) => GraphQLInterfaceType | null | undefined;\n\nexport type DirectiveMapper = (\n  directive: GraphQLDirective,\n  schema: GraphQLSchema\n) => GraphQLDirective | null | undefined;\n\nexport type GenericFieldMapper<F extends GraphQLFieldConfig<any, any> | GraphQLInputFieldConfig> = (\n  fieldConfig: F,\n  fieldName: string,\n  typeName: string,\n  schema: GraphQLSchema\n) => F | [string, F] | null | undefined;\n\nexport type FieldMapper = GenericFieldMapper<GraphQLFieldConfig<any, any>>;\n\nexport type ArgumentMapper = (\n  argumentConfig: GraphQLArgumentConfig,\n  fieldName: string,\n  typeName: string,\n  schema: GraphQLSchema\n) => GraphQLArgumentConfig | [string, GraphQLArgumentConfig] | null | undefined;\n\nexport type InputFieldMapper = GenericFieldMapper<GraphQLInputFieldConfig>;\n")))}d.isMDXComponent=!0}}]);