(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[6570],{5318:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return h}});var i=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(n),h=a,u=m["".concat(l,".").concat(h)]||m[h]||d[h]||r;return n?i.createElement(u,s(s({ref:t},p),{},{components:n})):i.createElement(u,s({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8050:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return o},toc:function(){return l},default:function(){return p}});var i=n(9603),a=n(120),r=(n(7378),n(5318)),s={id:"legacy-schema-directives",title:"Schema directives",description:"Using and implementing custom directives to transform schema types, fields, and arguments"},o={unversionedId:"legacy-schema-directives",id:"legacy-schema-directives",isDocsHomePage:!1,title:"Schema directives",description:"Using and implementing custom directives to transform schema types, fields, and arguments",source:"@site/docs/legacy-schema-directives.md",sourceDirName:".",slug:"/legacy-schema-directives",permalink:"/docs/legacy-schema-directives",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/legacy-schema-directives.md",version:"current",frontMatter:{id:"legacy-schema-directives",title:"Schema directives",description:"Using and implementing custom directives to transform schema types, fields, and arguments"}},l=[{value:"(At least) two strategies",id:"at-least-two-strategies",children:[]},{value:"Using schema directives",id:"using-schema-directives",children:[]},{value:"Implementing schema directives",id:"implementing-schema-directives",children:[]},{value:"Examples",id:"examples",children:[{value:"Uppercasing strings",id:"uppercasing-strings",children:[]},{value:"Fetching data from a REST API",id:"fetching-data-from-a-rest-api",children:[]},{value:"Formatting date strings",id:"formatting-date-strings",children:[]},{value:"Marking strings for internationalization",id:"marking-strings-for-internationalization",children:[]},{value:"Enforcing access permissions",id:"enforcing-access-permissions",children:[]},{value:"Enforcing value restrictions",id:"enforcing-value-restrictions",children:[]},{value:"Synthesizing unique IDs",id:"synthesizing-unique-ids",children:[]}]},{value:"Declaring schema directives",id:"declaring-schema-directives",children:[]}],c={toc:l};function p(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"directive")," is an identifier preceded by a ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," character, optionally followed by a list of named arguments, which can appear after almost any form of syntax in the GraphQL query or schema languages. Here's an example from the ",(0,r.kt)("a",{parentName:"p",href:"http://facebook.github.io/graphql/draft/#sec-Type-System.Directives"},"GraphQL draft specification")," that illustrates several of these possibilities:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'directive @deprecated(\n  reason: String = "No longer supported"\n) on FIELD_DEFINITION | ENUM_VALUE\n\ntype ExampleType {\n  newField: String\n  oldField: String @deprecated(reason: "Use `newField`.")\n}\n')),(0,r.kt)("p",null,"As you can see, the usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated(reason: ...)")," ",(0,r.kt)("em",{parentName:"p"},"follows")," the field that it pertains to (",(0,r.kt)("inlineCode",{parentName:"p"},"oldField"),'), though the syntax might remind you of "decorators" in other languages, which usually appear on the line above. Directives are typically ',(0,r.kt)("em",{parentName:"p"},"declared")," once, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"directive @deprecated ... on ...")," syntax, and then ",(0,r.kt)("em",{parentName:"p"},"used")," zero or more times throughout the schema document, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated(reason: ...)")," syntax."),(0,r.kt)("p",null,"The possible applications of directive syntax are numerous: enforcing access permissions, formatting date strings, auto-generating resolver functions for a particular backend API, marking strings for internationalization, synthesizing globally unique object identifiers, specifying caching behavior, skipping or including or deprecating fields, and just about anything else you can imagine."),(0,r.kt)("p",null,"This document focuses on directives that appear in GraphQL ",(0,r.kt)("em",{parentName:"p"},"schemas")," (as opposed to queries) written in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/graphql/pull/90"},"Schema Definition Language"),", or SDL for short. In the following sections, you will see how custom directives can be implemented and used to modify the structure and behavior of a GraphQL schema in ways that would not be possible using SDL syntax alone."),(0,r.kt)("h2",{id:"at-least-two-strategies"},"(At least) two strategies"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"graphql-tools")," provides ",(0,r.kt)("a",{parentName:"p",href:"/docs/schema-directives/"},"a newer functional approach")," for directive-based schema modification. The remainder of this document describes the earlier class-based mechanism. We believe the newer approach is easier to reason about, but older class-based schema directives are still supported, as long as the in-place schema modification techniques they employ do not yield an invalid schema."),(0,r.kt)("h2",{id:"using-schema-directives"},"Using schema directives"),(0,r.kt)("p",null,"Most of this document is concerned with ",(0,r.kt)("em",{parentName:"p"},"implementing")," schema directives, and some of the examples are quite complicated. No matter how many tools and best practices you have at your disposal, it can be difficult to implement a non-trivial class-based schema directive in a reliable, reusable way. Exhaustive testing is essential, and using a typed language like TypeScript is recommended, because there are so many different schema types to worry about."),(0,r.kt)("p",null,"However, the API we provide for ",(0,r.kt)("em",{parentName:"p"},"using")," a schema directive is extremely simple. Just import the implementation of the directive, then pass it to ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema")," via the ",(0,r.kt)("inlineCode",{parentName:"p"},"schemaDirectives")," argument, which is an object that maps directive names to directive implementations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { makeExecutableSchema } from "@graphql-tools/schema";\nimport { RenameDirective } from "fake-rename-directive-package";\n\nconst typeDefs = `\ntype Person @rename(to: "Human") {\n  name: String!\n  currentDateMinusDateOfBirth: Int @rename(to: "age")\n}`;\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    rename: RenameDirective\n  }\n});\n')),(0,r.kt)("p",null,"That's it. The implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"RenameDirective")," takes care of everything else. If you understand what the directive is supposed to do to your schema, then you do not have to worry about how it works."),(0,r.kt)("p",null,"Everything you read below addresses some aspect of how a directive like ",(0,r.kt)("inlineCode",{parentName:"p"},"@rename(to: ...)")," could be implemented. If that's not something you care about right now, feel free to skip the rest of this document. When you need it, it will be here."),(0,r.kt)("h2",{id:"implementing-schema-directives"},"Implementing schema directives"),(0,r.kt)("p",null,"Since the GraphQL specification does not discuss any specific implementation strategy for directives, it's up to each GraphQL server framework to expose an API for implementing new directives."),(0,r.kt)("p",null,"GraphQL Tools provides a convenient yet powerful tool for implementing directive syntax: the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ardatan/graphql-tools/blob/master/src/utils/SchemaDirectiveVisitor.ts"},(0,r.kt)("inlineCode",{parentName:"a"},"SchemaDirectiveVisitor"))," class."),(0,r.kt)("p",null,"To implement a schema directive using ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor"),", simply create a subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," that overrides one or more of the following visitor methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitSchema(schema: GraphQLSchema)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitScalar(scalar: GraphQLScalarType)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitObject(object: GraphQLObjectType)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitFieldDefinition(field: GraphQLField<any, any>, details: { objectType: GraphQLObjectType | GraphQLInterfaceType })")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitArgumentDefinition(argument: GraphQLArgument, objectType: GraphQLObjectType | GraphQLInterfaceType })")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitInterface(iface: GraphQLInterfaceType)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitUnion(union: GraphQLUnionType)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitEnum(type: GraphQLEnumType)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitEnumValue(value: GraphQLEnumValue, details: { enumType: GraphQLEnumType })")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitInputObject(object: GraphQLInputObjectType)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"visitInputFieldDefinition(field: GraphQLInputField, details: { objectType: GraphQLInputObjectType })"))),(0,r.kt)("p",null,"By overriding methods like ",(0,r.kt)("inlineCode",{parentName:"p"},"visitObject"),", a subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," expresses interest in certain schema types such as ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType")," (the first parameter type of ",(0,r.kt)("inlineCode",{parentName:"p"},"visitObject"),")."),(0,r.kt)("p",null,"These method names correspond to all possible ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-js/blob/a62eea88d5844a3bd9725c0f3c30950a78727f3e/src/language/directiveLocation.js#L22-L33"},"locations")," where a directive may be used in a schema. For example, the location ",(0,r.kt)("inlineCode",{parentName:"p"},"INPUT_FIELD_DEFINITION")," is handled by ",(0,r.kt)("inlineCode",{parentName:"p"},"visitInputFieldDefinition"),"."),(0,r.kt)("p",null,"Here is one possible implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated")," directive we saw above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { SchemaDirectiveVisitor } from "@graphql-tools/utils";\n\nclass DeprecatedDirective extends SchemaDirectiveVisitor {\n  public visitFieldDefinition(field: GraphQLField<any, any>) {\n    field.isDeprecated = true;\n    field.deprecationReason = this.args.reason;\n  }\n\n  public visitEnumValue(value: GraphQLEnumValue) {\n    value.isDeprecated = true;\n    value.deprecationReason = this.args.reason;\n  }\n}\n')),(0,r.kt)("p",null,"In order to apply this implementation to a schema that contains ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated")," directives, simply pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"DeprecatedDirective")," class to the ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema")," function via the ",(0,r.kt)("inlineCode",{parentName:"p"},"schemaDirectives")," option:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { makeExecutableSchema } from "@graphql-tools/schema";\n\nconst typeDefs = `\ntype ExampleType {\n  newField: String\n  oldField: String @deprecated(reason: "Use \\`newField\\`.")\n}`;\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    deprecated: DeprecatedDirective\n  }\n});\n')),(0,r.kt)("p",null,"Alternatively, if you want to modify an existing schema object, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor.visitSchemaDirectives")," interface directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n  deprecated: DeprecatedDirective\n});\n")),(0,r.kt)("p",null,"This syntax is especially useful for code-first schemas that wish to make use of directive implementations. For code-first schemas, directives are read from the ",(0,r.kt)("inlineCode",{parentName:"p"},"directives")," key within the ",(0,r.kt)("inlineCode",{parentName:"p"},"extensions")," field for each GraphQL entity, unless a different path is provided, as per below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n  deprecated: DeprecatedDirective\n}, undefined, ['custom', 'path', 'to', 'directives', 'within', 'the', 'extensions', 'object']);\n")),(0,r.kt)("p",null,"The second argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"visitSchemaDirectives")," refers to a shared context object that may be passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," classes -- it is not often used, and can usually be safely set to undefined."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-js/issues/1343"},"this ",(0,r.kt)("inlineCode",{parentName:"a"},"graphql-js")," issue")," for more information on directives with code-first schemas. We follow the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-js/issues/1343#issuecomment-479877640"},"Gatsby and graphql-compose convention")," of reading directives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"extensions")," field, but allow customization as above."),(0,r.kt)("p",null,"Note that a subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," may be instantiated multiple times to visit multiple different occurrences of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated")," directive. That's why you provide a class rather than an instance of that class."),(0,r.kt)("p",null,"If for some reason you have a schema that uses another name for the ",(0,r.kt)("inlineCode",{parentName:"p"},"@deprecated")," directive, but you want to use the same implementation, you can! The same ",(0,r.kt)("inlineCode",{parentName:"p"},"DeprecatedDirective")," class can be passed with a different name, simply by changing its key in the ",(0,r.kt)("inlineCode",{parentName:"p"},"schemaDirectives")," object passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema"),". In other words, ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," implementations are effectively anonymous, so it's up to whoever uses them to assign names to them."),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"To appreciate the range of possibilities enabled by ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor"),", let's examine a variety of practical examples."),(0,r.kt)("h3",{id:"uppercasing-strings"},"Uppercasing strings"),(0,r.kt)("p",null,"Suppose you want to ensure a string-valued field is converted to uppercase. Though this use case is simple, it's a good example of a directive implementation that works by wrapping a field's ",(0,r.kt)("inlineCode",{parentName:"p"},"resolve")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { defaultFieldResolver } from "graphql";\n\nconst typeDefs = `\ndirective @upper on FIELD_DEFINITION\n\ntype Query {\n  hello: String @upper\n}`;\n\nclass UpperCaseDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const { resolve = defaultFieldResolver } = field;\n    field.resolve = async function (...args) {\n      const result = await resolve.apply(this, args);\n      if (typeof result === "string") {\n        return result.toUpperCase();\n      }\n      return result;\n    };\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    upper: UpperCaseDirective,\n    upperCase: UpperCaseDirective\n  }\n});\n')),(0,r.kt)("p",null,"Notice how easy it is to handle both ",(0,r.kt)("inlineCode",{parentName:"p"},"@upper")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@upperCase")," with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"UpperCaseDirective")," implementation."),(0,r.kt)("h3",{id:"fetching-data-from-a-rest-api"},"Fetching data from a REST API"),(0,r.kt)("p",null,"Suppose you've defined an object type that corresponds to a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Representational_state_transfer"},"REST")," resource, and you want to avoid implementing resolver functions for every field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const typeDefs = `\ndirective @rest(url: String) on FIELD_DEFINITION\n\ntype Query {\n  people: [Person] @rest(url: "/api/v1/people")\n}`;\n\nclass RestDirective extends SchemaDirectiveVisitor {\n  public visitFieldDefinition(field) {\n    const { url } = this.args;\n    field.resolve = () => fetch(url);\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    rest: RestDirective\n  }\n});\n')),(0,r.kt)("p",null,"There are many more issues to consider when implementing a real GraphQL wrapper over a REST endpoint (such as how to do caching or pagination), but this example demonstrates the basic structure."),(0,r.kt)("h3",{id:"formatting-date-strings"},"Formatting date strings"),(0,r.kt)("p",null,"Suppose your resolver returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," object but you want to return a formatted string to the client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const typeDefs = `\ndirective @date(format: String) on FIELD_DEFINITION\n\nscalar Date\n\ntype Post {\n  published: Date @date(format: \"mmmm d, yyyy\")\n}`;\n\nclass DateFormatDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const { resolve = defaultFieldResolver } = field;\n    const { format } = this.args;\n    field.resolve = async function (...args) {\n      const date = await resolve.apply(this, args);\n      return require('dateformat')(date, format);\n    };\n    // The formatted Date becomes a String, so the field type must change:\n    field.type = GraphQLString;\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    date: DateFormatDirective\n  }\n});\n")),(0,r.kt)("p",null,"Of course, it would be even better if the schema author did not have to decide on a specific ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," format, but could instead leave that decision to the client. To make this work, the directive just needs to add an additional argument to the field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import formatDate from "dateformat";\nimport {\n  defaultFieldResolver,\n  GraphQLString,\n} from "graphql";\n\nconst typeDefs = `\ndirective @date(\n  defaultFormat: String = "mmmm d, yyyy"\n) on FIELD_DEFINITION\n\nscalar Date\n\ntype Query {\n  today: Date @date\n}`;\n\nclass FormattableDateDirective extends SchemaDirectiveVisitor {\n  public visitFieldDefinition(field) {\n    const { resolve = defaultFieldResolver } = field;\n    const { defaultFormat } = this.args;\n\n    field.args.push({\n      name: \'format\',\n      type: GraphQLString\n    });\n\n    field.resolve = async function (\n      source,\n      { format, ...otherArgs },\n      context,\n      info,\n    ) {\n      const date = await resolve.call(this, source, otherArgs, context, info);\n      // If a format argument was not provided, default to the optional\n      // defaultFormat argument taken by the @date directive:\n      return formatDate(date, format || defaultFormat);\n    };\n\n    field.type = GraphQLString;\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    date: FormattableDateDirective\n  }\n});\n')),(0,r.kt)("p",null,"Now the client can specify a desired ",(0,r.kt)("inlineCode",{parentName:"p"},"format")," argument when requesting the ",(0,r.kt)("inlineCode",{parentName:"p"},"Query.today")," field, or omit the argument to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"defaultFormat")," string specified in the schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { graphql } from "graphql";\n\ngraphql(schema, `query { today }`).then(result => {\n  // Logs with the default "mmmm d, yyyy" format:\n  console.log(result.data.today);\n});\n\ngraphql(schema, `query {\n  today(format: "d mmm yyyy")\n}`).then(result => {\n  // Logs with the requested "d mmm yyyy" format:\n  console.log(result.data.today);\n});\n')),(0,r.kt)("h3",{id:"marking-strings-for-internationalization"},"Marking strings for internationalization"),(0,r.kt)("p",null,"Suppose you have a function called ",(0,r.kt)("inlineCode",{parentName:"p"},"translate")," that takes a string, a path identifying that string's role in your application, and a target locale for the translation."),(0,r.kt)("p",null,"Here's how you might make sure ",(0,r.kt)("inlineCode",{parentName:"p"},"translate")," is used to localize the ",(0,r.kt)("inlineCode",{parentName:"p"},"greeting")," field of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Query")," type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const typeDefs = `\ndirective @intl on FIELD_DEFINITION\n\ntype Query {\n  greeting: String @intl\n}`;\n\nclass IntlDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field, details) {\n    const { resolve = defaultFieldResolver } = field;\n    field.resolve = async function (...args) {\n      const context = args[2];\n      const defaultText = await resolve.apply(this, args);\n      // In this example, path would be ["Query", "greeting"]:\n      const path = [details.objectType.name, field.name];\n      return translate(defaultText, path, context.locale);\n    };\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    intl: IntlDirective\n  }\n});\n')),(0,r.kt)("p",null,"GraphQL is great for internationalization, since a GraphQL server can access unlimited translation data, and clients can simply ask for the translations they need."),(0,r.kt)("h3",{id:"enforcing-access-permissions"},"Enforcing access permissions"),(0,r.kt)("p",null,"Imagine a hypothetical ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," directive that takes an argument ",(0,r.kt)("inlineCode",{parentName:"p"},"requires")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Role"),", which defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"ADMIN"),". This ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," directive can appear on an ",(0,r.kt)("inlineCode",{parentName:"p"},"OBJECT")," like ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," to set default access permissions for all ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," fields, as well as appearing on individual fields, to enforce field-specific ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," restrictions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @auth(\n  requires: Role = ADMIN,\n) on OBJECT | FIELD_DEFINITION\n\nenum Role {\n  ADMIN\n  REVIEWER\n  USER\n  UNKNOWN\n}\n\ntype User @auth(requires: USER) {\n  name: String\n  banned: Boolean @auth(requires: ADMIN)\n  canPost: Boolean @auth(requires: REVIEWER)\n}\n")),(0,r.kt)("p",null,"What makes this example tricky is that the ",(0,r.kt)("inlineCode",{parentName:"p"},"OBJECT")," version of the directive needs to wrap all fields of the object, even though some of those fields may be individually wrapped by ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," directives at the ",(0,r.kt)("inlineCode",{parentName:"p"},"FIELD_DEFINITION")," level, and we would prefer not to rewrap resolvers if we can help it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class AuthDirective extends SchemaDirectiveVisitor {\n  visitObject(type) {\n    this.ensureFieldsWrapped(type);\n    type._requiredAuthRole = this.args.requires;\n  }\n  // Visitor methods for nested types like fields and arguments\n  // also receive a details object that provides information about\n  // the parent and grandparent types.\n  visitFieldDefinition(field, details) {\n    this.ensureFieldsWrapped(details.objectType);\n    field._requiredAuthRole = this.args.requires;\n  }\n\n  ensureFieldsWrapped(objectType) {\n    // Mark the GraphQLObjectType object to avoid re-wrapping:\n    if (objectType._authFieldsWrapped) return;\n    objectType._authFieldsWrapped = true;\n\n    const fields = objectType.getFields();\n\n    Object.keys(fields).forEach(fieldName => {\n      const field = fields[fieldName];\n      const { resolve = defaultFieldResolver } = field;\n      field.resolve = async function (...args) {\n        // Get the required Role from the field first, falling back\n        // to the objectType if no Role is required by the field:\n        const requiredRole =\n          field._requiredAuthRole ||\n          objectType._requiredAuthRole;\n\n        if (! requiredRole) {\n          return resolve.apply(this, args);\n        }\n\n        const context = args[2];\n        const user = await getUser(context.headers.authToken);\n        if (! user.hasRole(requiredRole)) {\n          throw new Error("not authorized");\n        }\n\n        return resolve.apply(this, args);\n      };\n    });\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    auth: AuthDirective,\n    authorized: AuthDirective,\n    authenticated: AuthDirective\n  }\n});\n')),(0,r.kt)("p",null,"One drawback of this approach is that it does not guarantee fields will be wrapped if they are added to the schema after ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthDirective")," is applied, and the whole ",(0,r.kt)("inlineCode",{parentName:"p"},"getUser(context.headers.authToken)")," is a made-up API that would need to be fleshed out. In other words, we\u2019ve glossed over some of the details that would be required for a production-ready implementation of this directive, though we hope the basic structure shown here inspires you to find clever solutions to the remaining problems."),(0,r.kt)("h3",{id:"enforcing-value-restrictions"},"Enforcing value restrictions"),(0,r.kt)("p",null,"Suppose you want to enforce a maximum length for a string-valued field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const typeDefs = `\ndirective @length(max: Int) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION\n\ntype Query {\n  books: [Book]\n}\n\ntype Book {\n  title: String @length(max: 50)\n}\n\ntype Mutation {\n  createBook(book: BookInput): Book\n}\n\ninput BookInput {\n  title: String! @length(max: 50)\n}`;\n\nclass LengthDirective extends SchemaDirectiveVisitor {\n  visitInputFieldDefinition(field) {\n    this.wrapType(field);\n  }\n\n  visitFieldDefinition(field) {\n    this.wrapType(field);\n  }\n\n  // Replace field.type with a custom GraphQLScalarType that enforces the\n  // length restriction.\n  wrapType(field) {\n    if (isNonNullType(field.type) && isScalarType(field.type.ofType)) {\n      field.type = new GraphQLNonNull(\n        new LimitedLengthType(field.type.ofType, this.args.max));\n    } else if (isScalarType(field.type)) {\n      field.type = new LimitedLengthType(field.type, this.args.max);\n    } else {\n      throw new Error(`Not a scalar type: ${field.type}`);\n    }\n  }\n}\n\nclass LimitedLengthType extends GraphQLScalarType {\n  constructor(type, maxLength) {\n    super({\n      name: `LengthAtMost${maxLength}`,\n\n      // For more information about GraphQLScalar type (de)serialization,\n      // see the graphql-js implementation:\n      // https://github.com/graphql/graphql-js/blob/31ae8a8e8312/src/type/definition.js#L425-L446\n\n      serialize(value) {\n        value = type.serialize(value);\n        assert.isAtMost(value.length, maxLength);\n        return value;\n      },\n\n      parseValue(value) {\n        return type.parseValue(value);\n      },\n\n      parseLiteral(ast) {\n        return type.parseLiteral(ast);\n      }\n    });\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    length: LengthDirective\n  }\n});\n")),(0,r.kt)("h3",{id:"synthesizing-unique-ids"},"Synthesizing unique IDs"),(0,r.kt)("p",null,"Suppose your database uses incrementing IDs for each resource type, so IDs are not unique across all resource types. Here\u2019s how you might synthesize a field called ",(0,r.kt)("inlineCode",{parentName:"p"},"uid")," that combines the object type with various field values to produce an ID that\u2019s unique across your schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { GraphQLID } from "graphql";\nimport { createHash } from "crypto";\n\nconst typeDefs = `\ndirective @uniqueID(\n  # The name of the new ID field, "uid" by default:\n  name: String = "uid"\n\n  # Which fields to include in the new ID:\n  from: [String] = ["id"]\n) on OBJECT\n\n# Since this type just uses the default values of name and from,\n# we don\'t have to pass any arguments to the directive:\ntype Location @uniqueID {\n  id: Int\n  address: String\n}\n\n# This type uses both the person\'s name and the personID field,\n# in addition to the "Person" type name, to construct the ID:\ntype Person @uniqueID(from: ["name", "personID"]) {\n  personID: Int\n  name: String\n}`;\n\nclass UniqueIdDirective extends SchemaDirectiveVisitor {\n  visitObject(type) {\n    const { name, from } = this.args;\n    const fields = type.getFields();\n    if (name in fields) {\n      throw new Error(`Conflicting field name ${name}`);\n    }\n    fields[name] = {\n      name,\n      type: GraphQLID,\n      description: \'Unique ID\',\n      args: [],\n      resolve(object) {\n        const hash = createHash("sha1");\n        hash.update(type.name);\n        from.forEach(fieldName => {\n          hash.update(String(object[fieldName]));\n        });\n        return hash.digest("hex");\n      }\n    };\n  }\n}\n\nconst schema = makeExecutableSchema({\n  typeDefs,\n  schemaDirectives: {\n    uniqueID: UniqueIdDirective\n  }\n});\n')),(0,r.kt)("h2",{id:"declaring-schema-directives"},"Declaring schema directives"),(0,r.kt)("p",null,"While the above examples should be sufficient to implement any ",(0,r.kt)("inlineCode",{parentName:"p"},"@directive")," used in your schema, SDL syntax also supports declaring the names, argument types, default argument values, and permissible locations of any available directives:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"directive @auth(\n  requires: Role = ADMIN,\n) on OBJECT | FIELD_DEFINITION\n\nenum Role {\n  ADMIN\n  REVIEWER\n  USER\n  UNKNOWN\n}\n\ntype User @auth(requires: USER) {\n  name: String\n  banned: Boolean @auth(requires: ADMIN)\n  canPost: Boolean @auth(requires: REVIEWER)\n}\n")),(0,r.kt)("p",null,"This hypothetical ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," directive takes an argument named ",(0,r.kt)("inlineCode",{parentName:"p"},"requires")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Role"),", which defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"ADMIN")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," is used without passing an explicit ",(0,r.kt)("inlineCode",{parentName:"p"},"requires")," argument. The ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," directive can appear on an ",(0,r.kt)("inlineCode",{parentName:"p"},"OBJECT")," like ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," to set a default access control for all ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," fields, and also on individual fields, to enforce field-specific ",(0,r.kt)("inlineCode",{parentName:"p"},"@auth")," restrictions."),(0,r.kt)("p",null,"Enforcing the requirements of the declaration is something a ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," implementation could do itself, in theory, but the SDL syntax is easier to read and write, and provides value even if you're not using the ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," abstraction."),(0,r.kt)("p",null,"However, if you're implementing a reusable ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," for public consumption, you will probably not be the person writing the SDL syntax, so you may not have control over which directives the schema author decides to declare, and how. That's why a well-implemented, reusable ",(0,r.kt)("inlineCode",{parentName:"p"},"SchemaDirectiveVisitor")," should consider overriding the ",(0,r.kt)("inlineCode",{parentName:"p"},"getDirectiveDeclaration")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  DirectiveLocation,\n  GraphQLDirective,\n  GraphQLEnumType,\n} from \"graphql\";\n\nclass AuthDirective extends SchemaDirectiveVisitor {\n  public visitObject(object: GraphQLObjectType) {...}\n  public visitFieldDefinition(field: GraphQLField<any, any>) {...}\n\n  public static getDirectiveDeclaration(\n    directiveName: string,\n    schema: GraphQLSchema,\n  ): GraphQLDirective {\n    const previousDirective = schema.getDirective(directiveName);\n    if (previousDirective) {\n      // If a previous directive declaration exists in the schema, it may be\n      // better to modify it than to return a new GraphQLDirective object.\n      previousDirective.args.forEach(arg => {\n        if (arg.name === 'requires') {\n          // Lower the default minimum Role from ADMIN to REVIEWER.\n          arg.defaultValue = 'REVIEWER';\n        }\n      });\n\n      return previousDirective;\n    }\n\n    // If a previous directive with this name was not found in the schema,\n    // there are several options:\n    //\n    // 1. Construct a new GraphQLDirective (see below).\n    // 2. Throw an exception to force the client to declare the directive.\n    // 3. Return null, and forget about declaring this directive.\n    //\n    // All three are valid options, since the visitor will still work without\n    // any declared directives. In fact, unless you're publishing a directive\n    // implementation for public consumption, you can probably just ignore\n    // getDirectiveDeclaration altogether.\n\n    return new GraphQLDirective({\n      name: directiveName,\n      locations: [\n        DirectiveLocation.OBJECT,\n        DirectiveLocation.FIELD_DEFINITION,\n      ],\n      args: {\n        requires: {\n          // Having the schema available here is important for obtaining\n          // references to existing type objects, such as the Role enum.\n          type: (schema.getType('Role') as GraphQLEnumType),\n          // Set the default minimum Role to REVIEWER.\n          defaultValue: 'REVIEWER',\n        }\n      }]\n    });\n  }\n}\n")),(0,r.kt)("p",null,"Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"getDirectiveDeclaration")," method receives not only the name of the directive but also the ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLSchema")," object, it can modify and/or reuse previous declarations found in the schema, as an alternative to returning a totally new ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLDirective")," object. Either way, if the visitor returns a non-null ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLDirective")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"getDirectiveDeclaration"),", that declaration will be used to check arguments and permissible locations."))}p.isMDXComponent=!0}}]);