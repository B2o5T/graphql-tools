(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[1794],{5318:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5494:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var a=n(9603),r=n(120),o=(n(7378),n(5318)),s=["components"],i={id:"schema-delegation",title:"Schema delegation",description:"Forward queries to other schemas automatically"},l={unversionedId:"schema-delegation",id:"schema-delegation",isDocsHomePage:!1,title:"Schema delegation",description:"Forward queries to other schemas automatically",source:"@site/docs/schema-delegation.md",sourceDirName:".",slug:"/schema-delegation",permalink:"/docs/schema-delegation",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/schema-delegation.md",version:"current",frontMatter:{id:"schema-delegation",title:"Schema delegation",description:"Forward queries to other schemas automatically"},sidebar:"someSidebar",previous:{title:"Directive resolvers",permalink:"/docs/directive-resolvers"},next:{title:"Remote schemas",permalink:"/docs/remote-schemas"}},p=[{value:"Motivational example",id:"motivational-example",children:[]},{value:"API",id:"api",children:[{value:"delegateToSchema",id:"delegatetoschema",children:[]}]}],c={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Schema delegation is a way to automatically forward a query (or a part of a query) from a parent schema to another schema (called a ",(0,o.kt)("em",{parentName:"p"},"subschema"),") that is able to execute the query. Delegation is useful when the parent schema shares a significant part of its data model with the subschema. For example:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A GraphQL gateway that connects multiple existing endpoints together, each with its own schema, could be implemented as a parent schema that delegates portions of queries to the relevant subschemas."),(0,o.kt)("li",{parentName:"ul"},"Any local schema can directly wrap remote schemas and optionally extend them with additional fields. As long as schema delegation is unidirectional, no gateway is necessary. Simple examples are schemas that wrap other autogenerated schemas (e.g. Postgraphile, Hasura, Prisma) to add custom functionality.")),(0,o.kt)("p",null,"Delegation is performed by one function, ",(0,o.kt)("inlineCode",{parentName:"p"},"delegateToSchema"),", called from within a resolver function of the parent schema. The ",(0,o.kt)("inlineCode",{parentName:"p"},"delegateToSchema")," function sends the query subtree received by the parent resolver to the subschema that knows how to execute it. Fields for the merged types use the ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultMergedResolver")," resolver to extract the correct data from the query response."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql-tools")," package provides several related tools for managing schema delegation:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/remote-schemas/"},"Remote schemas")," - turning a remote GraphQL endpoint into a local schema"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/schema-wrapping/"},"Schema wrapping")," - modifying existing schemas -- usually remote, but possibly local -- when wrapping them to make delegation easier"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/stitch-api/"},"Schema stitching")," - merging multiple schemas into one")),(0,o.kt)("h2",{id:"motivational-example"},"Motivational example"),(0,o.kt)("p",null,"Let's consider two schemas, a subschema and a parent schema that reuses parts of a subschema. While the parent schema reuses the ",(0,o.kt)("em",{parentName:"p"},"definitions")," of the subschema, we want to keep the implementations separate, so that the subschema can be tested independently, or even used as a remote service."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"# Subschema\ntype Repository {\n  id: ID!\n  url: String\n  issues: [Issue]\n  userId: ID!\n}\n\ntype Issue {\n  id: ID!\n  text: String!\n  repository: Repository!\n}\n\ntype Query {\n  repositoryById(id: ID!): Repository\n  repositoriesByUserId(id: ID!): [Repository]\n}\n\n# Parent schema\ntype Repository {\n  id: ID!\n  url: String\n  issues: [Issue]\n  userId: ID!\n  user: User\n}\n\ntype Issue {\n  id: ID!\n  text: String!\n  repository: Repository!\n}\n\ntype User {\n  id: ID!\n  username: String\n  repositories: [Repository]\n}\n\ntype Query {\n  userById(id: ID!): User\n}\n")),(0,o.kt)("p",null,"Suppose we want the parent schema to delegate retrieval of repositories to the subschema, in order to execute queries such as this one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},'query {\n  userById(id: "1") {\n    id\n    username\n    repositories {\n      id\n      url\n      user {\n        username\n        id\n      }\n      issues {\n        text\n      }\n    }\n  }\n}\n')),(0,o.kt)("p",null,"The resolver function for the ",(0,o.kt)("inlineCode",{parentName:"p"},"repositories")," field of the ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," type would be responsible for the delegation, in this case. While it's possible to call a remote GraphQL endpoint or resolve the data manually, this would require us to transform the query manually, or always fetch all possible fields, which could lead to overfetching. Delegation automatically extracts the appropriate query to send to the subschema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"# To the subschema\nquery($id: ID!) {\n  repositoriesByUserId(id: $id) {\n    id\n    url\n    issues {\n      text\n    }\n  }\n}\n")),(0,o.kt)("p",null,"Delegation also removes the fields that don't exist on the subschema, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"user"),". This field would be retrieved from the parent schema using normal GraphQL resolvers."),(0,o.kt)("p",null,"Each field on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Repository")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Issue")," types should use the ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultMergedResolver")," to properly extract data from the delegated response. Although in the simplest case, the default resolver can be used for the merged types, ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultMergedResolver")," resolves aliases, converts custom scalars and enums to their internal representations, and maps errors."),(0,o.kt)("h2",{id:"api"},"API"),(0,o.kt)("h3",{id:"delegatetoschema"},"delegateToSchema"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"delegateToSchema")," method should be called with the following named options:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"delegateToSchema(options: {\n  schema: GraphQLSchema;\n  operation: 'query' | 'mutation' | 'subscription';\n  fieldName: string;\n  args?: Record<string, any>;\n  context: Record<string, any>;\n  info: GraphQLResolveInfo;\n  transforms?: Array<Transform>;\n}): Promise<any>\n")),(0,o.kt)("h4",{id:"schema-graphqlschema"},"schema: GraphQLSchema"),(0,o.kt)("p",null,"A subschema to delegate to."),(0,o.kt)("h4",{id:"operation-query--mutation--subscription"},"operation: 'query' | 'mutation' | 'subscription'"),(0,o.kt)("p",null,"The operation type to use during the delegation."),(0,o.kt)("h4",{id:"fieldname-string"},"fieldName: string"),(0,o.kt)("p",null,"A root field in a subschema from which the query should start."),(0,o.kt)("h4",{id:"args-recordstring-any"},"args: Record<string, any>"),(0,o.kt)("p",null,"Additional arguments to be passed to the field. Arguments passed to the field that is being resolved will be preserved if the subschema expects them, so you don't have to pass existing arguments explicitly, though you could use the additional arguments to override the existing ones. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"# Subschema\n\ntype Booking {\n  id: ID!\n}\n\ntype Query {\n  bookingsByUser(userId: ID!, limit: Int): [Booking]\n}\n\n# Schema\n\ntype User {\n  id: ID!\n  bookings(limit: Int): [Booking]\n}\n\ntype Booking {\n  id: ID!\n}\n")),(0,o.kt)("p",null,"If we delegate at ",(0,o.kt)("inlineCode",{parentName:"p"},"User.bookings")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Query.bookingsByUser"),", we want to preserve the ",(0,o.kt)("inlineCode",{parentName:"p"},"limit")," argument and add a ",(0,o.kt)("inlineCode",{parentName:"p"},"userId")," argument by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"User.id"),". So the resolver would look like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { delegateToSchema } from '@graphql-tools/delegate';\n\nconst resolvers = {\n  User: {\n    bookings(parent, args, context, info) {\n      return delegateToSchema({\n        schema: subschema,\n        operation: 'query',\n        fieldName: 'bookingsByUser',\n        args: {\n          userId: parent.id,\n        },\n        context,\n        info,\n      });\n    },\n    ...\n  },\n  ...\n};\n")),(0,o.kt)("h4",{id:"context-recordstring-any"},"context: Record<string, any>"),(0,o.kt)("p",null,"GraphQL context that is going to be passed to the subschema execution or subscription call."),(0,o.kt)("h4",{id:"info-graphqlresolveinfo"},"info: GraphQLResolveInfo"),(0,o.kt)("p",null,"GraphQL resolve info of the current resolver. Provides access to the subquery that starts at the current resolver."),(0,o.kt)("h4",{id:"transforms-array--transform-"},"transforms: Array < Transform >"),(0,o.kt)("p",null,"Any additional operation ",(0,o.kt)("a",{parentName:"p",href:"/docs/schema-wrapping/"},"transforms")," to apply to the query and results. Transforms are specified similarly to the transforms used in conjunction with schema wrapping, but only the operational components of transforms will be used by ",(0,o.kt)("inlineCode",{parentName:"p"},"delegateToSchema"),", i.e. any specified ",(0,o.kt)("inlineCode",{parentName:"p"},"transformRequest")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"transformResult")," functions. The following transforms are automatically applied during schema delegation to translate between source and target types and fields:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ExpandAbstractTypes"),": If an abstract type within a document does not exist within the target schema, expand the type to each and any of its implementations that do exist."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"FilterToSchema"),": Remove all fields, variables and fragments for types that don't exist within the target schema."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"AddTypenameToAbstract"),": Add ",(0,o.kt)("inlineCode",{parentName:"li"},"__typename")," to all abstract types in the document, necessary for type resolution of interfaces within the source schema to work."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"CheckResultAndHandleErrors"),": Given a result from a subschema, propagate errors so that they match the correct subfield. Also provide the correct key if aliases are used."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"AddSelectionSets"),": activated by schema stitching to add selection sets into outgoing requests from the gateway schema. These selections collect key fields used to perform queries for related records from other subservices.")))}d.isMDXComponent=!0}}]);