(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[1696],{5318:function(e,t,n){"use strict";n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),h=l(n),d=r,u=h["".concat(c,".").concat(d)]||h[d]||p[d]||s;return n?a.createElement(u,i(i({ref:t},m),{},{components:n})):a.createElement(u,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var l=2;l<s;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6910:function(e,t,n){"use strict";t.Z=n.p+"assets/images/distributed-graph-6962df44b42254da48d3557e74e5d074.png"},8266:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return o},toc:function(){return c},default:function(){return m}});var a=n(9603),r=n(120),s=(n(7378),n(5318)),i={id:"stitch-combining-schemas",title:"Combining schemas",sidebar_label:"Combining schemas"},o={unversionedId:"stitch-combining-schemas",id:"stitch-combining-schemas",isDocsHomePage:!1,title:"Combining schemas",description:"Schema stitching (@graphql-tools/stitch) creates a single GraphQL gateway schema from multiple underlying GraphQL services. Unlike schema merging, which simply combines local schema instances, stitching builds a combined proxy layer that delegates requests through to underlying service APIs. As of GraphQL Tools v7, stitching is fairly comparable to Apollo Federation with automated query planning, merged types, and declarative schema directives.",source:"@site/docs/stitch-combining-schemas.md",sourceDirName:".",slug:"/stitch-combining-schemas",permalink:"/docs/stitch-combining-schemas",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/stitch-combining-schemas.md",version:"current",sidebar_label:"Combining schemas",frontMatter:{id:"stitch-combining-schemas",title:"Combining schemas",sidebar_label:"Combining schemas"},sidebar:"someSidebar",previous:{title:"Schema merging",permalink:"/docs/schema-merging"},next:{title:"Type merging",permalink:"/docs/stitch-type-merging"}},c=[{value:"Why stitching?",id:"why-stitching",children:[]},{value:"Getting started",id:"getting-started",children:[]},{value:"Subschema configs",id:"subschema-configs",children:[]},{value:"Stitching remote schemas",id:"stitching-remote-schemas",children:[]},{value:"Duplicate types",id:"duplicate-types",children:[{value:"Automatic merge",id:"automatic-merge",children:[]},{value:"Manual resolution",id:"manual-resolution",children:[]}]},{value:"Adding transforms",id:"adding-transforms",children:[]},{value:"Error handling",id:"error-handling",children:[]}],l={toc:c};function m(e){var t=e.components,i=(0,r.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,a.Z)({},l,i,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Schema stitching (",(0,s.kt)("inlineCode",{parentName:"p"},"@graphql-tools/stitch"),") creates a single GraphQL gateway schema from multiple underlying GraphQL services. Unlike ",(0,s.kt)("a",{parentName:"p",href:"/docs/merge-schemas"},"schema merging"),", which simply combines local schema instances, stitching builds a combined proxy layer that delegates requests through to underlying service APIs. As of GraphQL Tools v7, stitching is fairly comparable to ",(0,s.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/federation/"},"Apollo Federation")," with automated query planning, merged types, and declarative schema directives."),(0,s.kt)("p",null,"Note that schema stitching is a superset of the ",(0,s.kt)("a",{parentName:"p",href:"/docs/schema-wrapping"},"schema wrapping")," API. Rather than wrapping schemas individually and then combining them, ",(0,s.kt)("inlineCode",{parentName:"p"},"stitchSchemas")," may be used directly to handle all wrapping concerns."),(0,s.kt)("h2",{id:"why-stitching"},"Why stitching?"),(0,s.kt)("p",null,"One of the main benefits of GraphQL is that we can query for all data in a single request to one schema. As that schema grows though, it may become preferable to break it up into separate modules or microservices that can be developed independently. We may also want to integrate the schemas we own with third-party schemas, allowing mashups with external data."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"distributed service graph",src:n(6910).Z})),(0,s.kt)("p",null,"In these cases, ",(0,s.kt)("inlineCode",{parentName:"p"},"stitchSchemas")," is used to combine multiple GraphQL APIs into one unified gateway proxy schema that knows how to delegate parts of a request to the relevant underlying subschemas. These subschemas may be local GraphQL instances or APIs running on remote servers."),(0,s.kt)("h2",{id:"getting-started"},"Getting started"),(0,s.kt)("p",null,"In this example we'll stitch together two very simple schemas representing a system of users and posts. You can find many supporting examples of stitching concepts in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook"},"Schema Stitching Handbook"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { makeExecutableSchema } from '@graphql-tools/schema';\nimport { stitchSchemas } from '@graphql-tools/stitch';\n\nlet postsSchema = makeExecutableSchema({\n  typeDefs: `\n    type Post {\n      id: ID!\n      text: String\n      userId: ID!\n    }\n\n    type Query {\n      postById(id: ID!): Post\n      postsByUserId(userId: ID!): [Post]!\n    }\n  `,\n  resolvers: { ... }\n});\n\nlet usersSchema = makeExecutableSchema({\n  typeDefs: `\n    type User {\n      id: ID!\n      email: String\n    }\n\n    type Query {\n      userById(id: ID!): User\n    }\n  `,\n  resolvers: { ... }\n});\n\n// setup subschema configurations\nexport const postsSubschema = { schema: postsSchema };\nexport const usersSubschema = { schema: usersSchema };\n\n// build the combined schema\nexport const gatewaySchema = stitchSchemas({\n  subschemas: [\n    postsSubschema,\n    usersSubschema,\n  ]\n});\n")),(0,s.kt)("p",null,"This process builds two GraphQL schemas, places them each into subschema configuration wrappers (discussed below), and then passes the subschemas to ",(0,s.kt)("inlineCode",{parentName:"p"},"stitchSchemas")," to produce one combined schema with the following root fields:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  postById(id: ID!): Post\n  postsByUserId(userId: ID!): [Post]!\n  userById(id: ID!): User\n}\n")),(0,s.kt)("p",null,"We now have a single gateway schema that allows data from either subschema to be requested in the same query."),(0,s.kt)("h2",{id:"subschema-configs"},"Subschema configs"),(0,s.kt)("p",null,'In the example above, the extra "subschema" wrapper objects may look verbose at first glance, but they are actually basic implementations of the ',(0,s.kt)("inlineCode",{parentName:"p"},"SubschemaConfig")," interface that accepts several additional settings (discussed throughout this guide):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"export interface SubschemaConfig {\n  schema: GraphQLSchema;\n  rootValue?: Record<string, any>;\n  executor?: Executor;\n  subscriber?: Subscriber;\n  createProxyingResolver?: CreateProxyingResolverFn;\n  transforms?: Array<Transform>;\n  merge?: Record<string, MergedTypeConfig>;\n  batch?: boolean;\n  batchingOptions?: {\n    extensionsReducer?: (mergedExtensions: Record<string, any>, executionParams: ExecutionParams) => Record<string, any>;\n    dataLoaderOptions?: DataLoader.Options<K, V, C>;\n  }\n}\n")),(0,s.kt)("p",null,"Subschema config should ",(0,s.kt)("em",{parentName:"p"},"directly")," provide as many settings as possible to avoid unnecessary layers of delegation. For example, while we ",(0,s.kt)("em",{parentName:"p"},"could")," pre-wrap a subschema with transforms and a remote executor, that would be far less efficient than providing the ",(0,s.kt)("inlineCode",{parentName:"p"},"schema"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"transforms"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"executor")," options directly to subschema config."),(0,s.kt)("p",null,"Also note that these subschema config objects may need to be referenced again in other stitching contexts, such as ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-schema-extensions"},"schema extensions"),". With that in mind, you may want to export your subschema configs from their module(s)."),(0,s.kt)("h2",{id:"stitching-remote-schemas"},"Stitching remote schemas"),(0,s.kt)("p",null,"To include a remote schema in the combined gateway, you must provide at least the ",(0,s.kt)("inlineCode",{parentName:"p"},"schema")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"executor")," subschema config options, and an optional ",(0,s.kt)("inlineCode",{parentName:"p"},"subscriber")," for subscriptions:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { introspectSchema } from '@graphql-tools/wrap';\nimport { fetch } from 'cross-fetch';\nimport { print } from 'graphql';\n\nasync function remoteExecutor({ document, variables }) {\n  const query = print(document);\n  const fetchResult = await fetch('https://my.remote.service/graphql', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ query, variables }),\n  });\n  return fetchResult.json();\n}\n\nexport const postsSubschema = {\n  schema: await introspectSchema(remoteExecutor),\n  executor: remoteExecutor,\n  // subscriber: remoteSubscriber\n};\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"schema"),": this is a non-executable schema representing the remote API. The remote schema may be obtained using ",(0,s.kt)("a",{parentName:"li",href:"/docs/remote-schemas/#introspectschemaexecutor-context"},"introspection"),", or fetched as a flat SDL string (from a server or repo) and built into a schema using ",(0,s.kt)("a",{parentName:"li",href:"https://graphql.org/graphql-js/utilities/#buildschema"},(0,s.kt)("inlineCode",{parentName:"a"},"buildSchema")),". Note that not all GraphQL servers enable introspection, and those that do will not include custom directives."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"executor"),": is a generic method that performs requests to a remote schema. It's quite simple to ",(0,s.kt)("a",{parentName:"li",href:"/docs/remote-schemas#creating-an-executor"},"write your own"),". Subschema config uses the executor for query and mutation operations. See ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/combining-local-and-remote-schemas"},"handbook example"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"subscriber"),": to enable subscription operations, include a ",(0,s.kt)("a",{parentName:"li",href:"/docs/remote-schemas#creating-a-subscriber"},"subscriber function")," that returns an AsyncIterator. See ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/mutations-and-subscriptions"},"handbook example"),".")),(0,s.kt)("h2",{id:"duplicate-types"},"Duplicate types"),(0,s.kt)("p",null,"Stitching has two strategies for handling types duplicated across subschemas: an automatic merge strategy (default), and an older manual resolution strategy. You may select between these strategies using the ",(0,s.kt)("inlineCode",{parentName:"p"},"mergeTypes")," option."),(0,s.kt)("h3",{id:"automatic-merge"},"Automatic merge"),(0,s.kt)("p",null,"Types with the same name are automatically merged by default in GraphQL Tools v7. That means objects, interfaces, and input objects with the same name will consolidate their fields across subschemas, and unions/enums will consolidate all of their members. The combined gateway schema will then smartly delegate portions of a request to the proper origin subschema(s). See ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging/"},"type merging guide")," for a comprehensive overview."),(0,s.kt)("p",null,"Automatic merging will only encounter conflicts on type descriptions and fields. By default, the final definition of a type or field found in the subschemas array is used, or a specific definition may be ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging#canonical-definitions"},"marked as canonical")," to prioritize it. You may customize all selection logic using ",(0,s.kt)("inlineCode",{parentName:"p"},"typeMergingOptions"),"; the following example prefers the ",(0,s.kt)("em",{parentName:"p"},"first")," definition of each conflicting element found in the subschemas array:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const gatewaySchema = stitchSchemas({\n  subschemas: [...],\n  mergeTypes: true, // << default in v7\n  typeMergingOptions: {\n    // select a preferred type candidate to provide definitions:\n    typeCandidateMerger: (candidates) => candidate[0],\n    // and/or itemize the selection of other specific definitions:\n    typeDescriptionsMerger: (candidates) => candidate[0].type.description,\n    fieldConfigMerger: (candidates) => candidate[0].fieldConfig,\n    inputFieldConfigMerger: (candidates) => candidate[0].inputFieldConfig,\n    enumValueConfigMerger: (candidates) => candidate[0].enumValueConfig,\n  },\n});\n")),(0,s.kt)("h4",{id:"merge-validations"},"Merge validations"),(0,s.kt)("p",null,"The automatic merge strategy also validates the integrity of merged schemas. Validations may be set to ",(0,s.kt)("inlineCode",{parentName:"p"},"error"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"warn"),", or ",(0,s.kt)("inlineCode",{parentName:"p"},"off")," for the entire schema or scoped for specific types and fields:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const gatewaySchema = stitchSchemas({\n  subschemas: [...],\n  typeMergingOptions: {\n    validationSettings: {\n      validationLevel: 'error',\n      strictNullComparison: false, // << gateway \"String\" may proxy subschema \"String!\"\n      proxiableScalars: {\n        ID: ['String'], // << gateway \"ID\" may proxy subschema \"String\"\n      }\n    },\n    validationScopes: {\n      // scope to specific element paths\n      'User.id': {\n        validationLevel: 'warn',\n        strictNullComparison: true,\n      },\n    }\n  },\n});\n")),(0,s.kt)("h3",{id:"manual-resolution"},"Manual resolution"),(0,s.kt)("p",null,"By setting ",(0,s.kt)("inlineCode",{parentName:"p"},"mergeTypes: false"),", only the final description and fields for a type found in the subschemas array will be used, and automated query planning will be disabled. You may manually resolve differences between conflicting types with an ",(0,s.kt)("inlineCode",{parentName:"p"},"onTypeConflict")," handler:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const gatewaySchema = stitchSchemas({\n  subschemas: [...],\n  mergeTypes: false,\n  onTypeConflict: (left, right, info) => {\n    return info.left.schema.version >= info.right.schema.version ? left : right;\n  }\n});\n")),(0,s.kt)("h2",{id:"adding-transforms"},"Adding transforms"),(0,s.kt)("p",null,"Another strategy to avoid conflicts while combining schemas is to modify one or more of the subschemas using ",(0,s.kt)("a",{parentName:"p",href:"/docs/schema-wrapping#transform"},"transforms"),". Transforming allows a schema to be groomed in such ways as adding namespaces, renaming types, or removing fields (to name a few) prior to stitching it into the combined gateway schema. These transforms should be added directly to subschema config:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { FilterRootFields, RenameTypes } from '@graphql-tools/wrap';\n\nconst postsSubschema = {\n  schema: postsSchema,\n  transforms: [\n    new FilterRootFields((operation, rootField) => rootField !== 'postsByUserId'),\n    new RenameTypes((name) => `Post_${name}`),\n  ],\n};\n")),(0,s.kt)("p",null,"In the example above, we transform the ",(0,s.kt)("inlineCode",{parentName:"p"},"postsSchema")," by removing the ",(0,s.kt)("inlineCode",{parentName:"p"},"postsByUserId")," root field and adding a ",(0,s.kt)("inlineCode",{parentName:"p"},"Post_")," prefix to all types in the schema. These modifications will only be present in the combined gateway schema."),(0,s.kt)("p",null,"Note that when ",(0,s.kt)("a",{parentName:"p",href:"#automatic-merge"},"automatically merging types"),", all transforms are applied ",(0,s.kt)("em",{parentName:"p"},"prior")," to merging. That means transformed types will merge based on their transformed names within the combined gateway schema."),(0,s.kt)("h2",{id:"error-handling"},"Error handling"),(0,s.kt)("p",null,"Whether you're ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging"},"merging types"),", using ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-schema-extensions"},"schema extensions"),", or simply combining schemas, any errors returned by a subschema will flow through the stitching process and report at their mapped output positions. It's fairly seamless to provide quality errors from a stitched schema by following some basic guidelines:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Report errors!")," Having a subschema return ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," without an error for missing or failed records is a poor development experience to begin with. This omission will compound should an unexpected value produce a misleading failure in gateway stitching. Reporting ",(0,s.kt)("a",{parentName:"p",href:"https://spec.graphql.org/June2018/#sec-Errors"},"proper GraphQL errors")," will contextualize failures in subschemas, and by extension, within the stitched schema.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Map errors to array positions"),". When returning arrays of records (a common pattern while ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging#batching"},"batch loading"),"), make sure to return errors for specific array positions rather than erroring out the entire array. For example, an array should be resolved as:"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"posts() {\n  return [\n    { id: '1', ... },\n    new NotFoundError(),\n    { id: '3', ... },\n  ];\n}\n")),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("strong",{parentName:"li"},"Assure valid error paths"),". The ",(0,s.kt)("a",{parentName:"li",href:"https://spec.graphql.org/June2018/#sec-Errors"},"GraphQL errors spec")," prescribes a ",(0,s.kt)("inlineCode",{parentName:"li"},"path")," attribute mapping an error to its corresponding document position. Stitching uses these paths to remap subschema errors into the combined result. While GraphQL libraries should automatically configure this ",(0,s.kt)("inlineCode",{parentName:"li"},"path")," for you, the accuracy ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/rmosolgo/graphql-ruby/issues/3193"},"may vary by programming language"),".")))}m.isMDXComponent=!0}}]);