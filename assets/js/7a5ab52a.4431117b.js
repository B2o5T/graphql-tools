(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[5662],{5318:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return m}});var i=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,h=u["".concat(c,".").concat(m)]||u[m]||d[m]||r;return n?i.createElement(h,s(s({ref:t},p),{},{components:n})):i.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},471:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c},default:function(){return p}});var i=n(9603),a=n(120),r=(n(7378),n(5318)),s={id:"stitch-directives-sdl",title:"Directives SDL",sidebar_label:"Directives SDL"},o={unversionedId:"stitch-directives-sdl",id:"stitch-directives-sdl",isDocsHomePage:!1,title:"Directives SDL",description:"Stitching directives (@graphql-tools/stitching-directives) may be used to configure a stitched gateway directly through the Schema Definition Language (SDL) of its subservices. The advantage of this approach is that all schema and type merging configuration is represented in a single document managed by each subservice, and can be reloaded by the gateway on the fly without a formal deploy or server restart.",source:"@site/docs/stitch-directives-sdl.md",sourceDirName:".",slug:"/stitch-directives-sdl",permalink:"/docs/stitch-directives-sdl",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/stitch-directives-sdl.md",version:"current",sidebar_label:"Directives SDL",frontMatter:{id:"stitch-directives-sdl",title:"Directives SDL",sidebar_label:"Directives SDL"},sidebar:"someSidebar",previous:{title:"Type merging",permalink:"/docs/stitch-type-merging"},next:{title:"Extending stitched schemas",permalink:"/docs/stitch-schema-extensions"}},c=[{value:"Overview",id:"overview",children:[]},{value:"Directives glossary",id:"directives-glossary",children:[]},{value:"Schema setup",id:"schema-setup",children:[{value:"Subservice setup",id:"subservice-setup",children:[]},{value:"Gateway setup",id:"gateway-setup",children:[]}]},{value:"Recipes",id:"recipes",children:[{value:"Picked keys",id:"picked-keys",children:[]},{value:"Multiple arguments",id:"multiple-arguments",children:[]},{value:"Object keys",id:"object-keys",children:[]},{value:"Typed inputs",id:"typed-inputs",children:[]},{value:"Nested inputs",id:"nested-inputs",children:[]}]},{value:"Versioning &amp; release",id:"versioning--release",children:[]}],l={toc:c};function p(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,i.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Stitching directives (",(0,r.kt)("inlineCode",{parentName:"p"},"@graphql-tools/stitching-directives"),") may be used to configure a stitched gateway directly through the Schema Definition Language (SDL) of its subservices. The advantage of this approach is that all schema ",(0,r.kt)("em",{parentName:"p"},"and type merging configuration")," is represented in a single document managed by each subservice, and can be reloaded by the gateway on the fly without a formal deploy or server restart."),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Using SDL directives, a subservice may express its complete schema ",(0,r.kt)("em",{parentName:"p"},"and type merging configuration")," in a single document. See related ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/stitching-directives-sdl"},"handbook example")," for a working demonstration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'# --- Users schema ---\ntype User {\n  id: ID!\n  username: String!\n  email: String!\n}\n\ntype Query {\n  users(ids: [ID!]!): [User]! @merge(keyField: "id") @canonical\n}\n\n# --- Posts schema ---\ntype Post {\n  id: ID!\n  message: String!\n  author: User\n}\n\ntype User {\n  id: ID!\n  posts: [Post]\n}\n\ntype Query {\n  post(id: ID!): Post\n  users(ids: [ID!]!): [User]! @merge(keyField: "id")\n}\n')),(0,r.kt)("p",null,"In the above example, the Users and Posts schemas will be combined in the stitched gateway and provide all of their own merged type configuration. All SDL directives will translate directly into the static configurations discussed in ",(0,r.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging"},"type merging docs"),". See the ",(0,r.kt)("a",{parentName:"p",href:"#recipes"},"recipes")," section below for some common patterns."),(0,r.kt)("h2",{id:"directives-glossary"},"Directives glossary"),(0,r.kt)("p",null,"By default, stitching directives use the following definitions (though the names of these directives ",(0,r.kt)("a",{parentName:"p",href:"#customizing-directive-names"},"may be customized"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"directive @merge(keyField: String, keyArg: String, additionalArgs: String, key: [String!], argsExpr: String) on FIELD_DEFINITION\ndirective @key(selectionSet: String!) on OBJECT\ndirective @computed(selectionSet: String!) on FIELD_DEFINITION\ndirective @canonical on OBJECT | INTERFACE | INPUT_OBJECT | UNION | ENUM | SCALAR | FIELD_DEFINITION | INPUT_FIELD_DEFINITION\n")),(0,r.kt)("p",null,"The function of these directives are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"@merge"),":")," denotes a root field used to query a merged type across services. The marked field's name is analogous to the ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldName")," setting in ",(0,r.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging#basic-example"},"merged type configuration"),", while the field's arguments and return type are used to infer merge configuration. Directive arguments tune the merge behavior (see ",(0,r.kt)("a",{parentName:"p",href:"#recipes"},"example recipes"),"):"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"keyField"),": specifies the name of a field to pick off origin objects as the key value. When omitted, a ",(0,r.kt)("inlineCode",{parentName:"li"},"@key")," directive must be included on the return type's definition to be built into an ",(0,r.kt)("a",{parentName:"li",href:"#object-keys"},"object key"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"keyArg"),": specifies which field argument receives the merge key. This may be omitted for fields with only one argument where the recipient can be inferred."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"additionalArgs"),": specifies a string of additional keys and values to apply to other arguments, formatted as ",(0,r.kt)("inlineCode",{parentName:"li"},'""" arg1: "value", arg2: "value" """'),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"em"},"key"),": advanced use only;")," Allows building a custom key just for the argument from the selectionSet included by the ",(0,r.kt)("inlineCode",{parentName:"li"},"@key")," directive."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"em"},"argsExpr"),": advanced use only;")," This argument specifies a string expression that allows more customization of the input arguments. Rules for evaluation of this argument are as follows:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"basic object parsing of the input key: ",(0,r.kt)("inlineCode",{parentName:"li"},'"arg1: $key.arg1, arg2: $key.arg2"')),(0,r.kt)("li",{parentName:"ul"},"any expression enclosed by double brackets will be evaluated once for each of the requested keys, and then sent as a list: ",(0,r.kt)("inlineCode",{parentName:"li"},'"input: { keys: [[$key]] }"')),(0,r.kt)("li",{parentName:"ul"},"selections from the key can be referenced by using the $ sign and dot notation: ",(0,r.kt)("inlineCode",{parentName:"li"},'"upcs: [[$key.upc]]"'),", so that ",(0,r.kt)("inlineCode",{parentName:"li"},"$key.upc")," refers to the ",(0,r.kt)("inlineCode",{parentName:"li"},"upc")," field of the key."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"@key"),":")," specifies a base selection set needed to merge the annotated type across subschemas. Analogous to the ",(0,r.kt)("inlineCode",{parentName:"p"},"selectionSet")," setting specified in ",(0,r.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging#basic-example"},"merged type configuration"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"@computed"),":")," specifies a selection of fields required from other services to compute the value of this field. These additional fields are only selected when the computed field is requested. Analogous to ",(0,r.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging#computed-fields"},"computed field")," in merged type configuration. Computed field dependencies must be sent into the subservice using an ",(0,r.kt)("a",{parentName:"p",href:"#object-keys"},"object key"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"@canonical"),":")," specifies types and fields that provide a ",(0,r.kt)("a",{parentName:"p",href:"/docs/stitch-type-merging#canonical-definitions"},"canonical definition")," to be built into the gateway schema. Useful for selecting preferred characteristics among types and fields that overlap across subschemas. Root fields marked as canonical specify which subschema the field proxies for new queries entering the graph."))),(0,r.kt)("h4",{id:"customizing-directive-names"},"Customizing directive names"),(0,r.kt)("p",null,"You may use the ",(0,r.kt)("inlineCode",{parentName:"p"},"stitchingDirectives")," helper to build your own type definitions and validator with custom names. For example, the configuration below creates the resources for ",(0,r.kt)("inlineCode",{parentName:"p"},"@myKey"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@myMerge"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"@myComputed")," directives:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { stitchingDirectives } = require('@graphql-tools/stitching-directives');\nconst {\n  allStitchingDirectivesTypeDefs,\n  stitchingDirectivesValidator\n} = stitchingDirectives({\n  keyDirectiveName: 'myKey',\n  mergeDirectiveName: 'myMerge',\n  computedDirectiveName: 'myComputed',\n});\n")),(0,r.kt)("h2",{id:"schema-setup"},"Schema setup"),(0,r.kt)("p",null,"To setup stitching directives, you'll need to install their definitions into each subschema, and then add a transformer to the stitched gateway that reads them. See related ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/stitching-directives-sdl"},"handbook example")," for a complete demonstration."),(0,r.kt)("h3",{id:"subservice-setup"},"Subservice setup"),(0,r.kt)("p",null,"When setting up a subservice, you'll need to do three things:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { makeExecutableSchema } = require('@graphql-tools/schema');\nconst { stitchingDirectives } = require('@graphql-tools/stitching-directives');\nconst {\n  allStitchingDirectivesTypeDefs,\n  stitchingDirectivesValidator\n} = stitchingDirectives();\n\n// 1. include directive type definitions...\nconst typeDefs = `\n  ${allStitchingDirectivesTypeDefs}\n  # schema here ...\n  type Query {\n    # schema here ...\n    _sdl: String!\n  }\n`;\n\nmodule.exports = makeExecutableSchema({\n  // 2. include the stitching directives validator...\n  schemaTransforms: [stitchingDirectivesValidator],\n  typeDefs,\n  resolvers: {\n    Query: {\n      // 3. setup a query that exposes the raw SDL...\n      _sdl: () => typeDefs\n    }\n  }\n});\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Include ",(0,r.kt)("inlineCode",{parentName:"li"},"allStitchingDirectivesTypeDefs")," in your schema's type definitions string (these define the schema of the directives themselves)."),(0,r.kt)("li",{parentName:"ol"},"Include a ",(0,r.kt)("inlineCode",{parentName:"li"},"stitchingDirectivesValidator")," in your executable schema (highly recommended)."),(0,r.kt)("li",{parentName:"ol"},"Setup a query field that returns the schema's raw type definitions string (see the ",(0,r.kt)("inlineCode",{parentName:"li"},"_sdl")," field example above). This field is extremely important for exposing the annotated SDL to your stitched gateway. Unfortunately, custom directives cannot be obtained through schema introspection.")),(0,r.kt)("h3",{id:"gateway-setup"},"Gateway setup"),(0,r.kt)("p",null,"When setting up the stitched gateway, you'll need to do two things:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { stitchSchemas } = require('@graphql-tools/stitch');\nconst { stitchingDirectivesTransformer } = require('@graphql-tools/stitching-directives')();\nconst { print, buildSchema } = require('graphql');\nconst { fetch } = require('cross-fetch');\n\nasync function createGatewaySchema() {\n  const usersExec = createRemoteExecutor('http://localhost:4001/graphql');\n  const postsExec = createRemoteExecutor('http://localhost:4002/graphql');\n\n  return stitchSchemas({\n    // 1. include directives transformer...\n    subschemaConfigTransforms: [stitchingDirectivesTransformer],\n    subschemas: [{\n      schema: await fetchRemoteSchema(usersExec),\n      executor: usersExec,\n    }, {\n      schema: await fetchRemoteSchema(postsExec),\n      executor: postsExec,\n    }]\n  });\n}\n\nfunction createRemoteExecutor(url) {\n  return async ({ document, variables }) => {\n    const query = typeof document === 'string' ? document : print(document);\n    const fetchResult = await fetch(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ query, variables }),\n    });\n    return fetchResult.json();\n  };\n}\n\nasync function fetchRemoteSchema(executor) {\n  // 2. fetch schemas from their raw SDL queries...\n  const result = await executor({ document: '{ _sdl }' });\n  return buildSchema(result.data._sdl);\n}\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Include the ",(0,r.kt)("inlineCode",{parentName:"li"},"stitchingDirectivesTransformer")," in your stitched gateway's config transforms. This will read SDL directives into the stitched schema's static configuration."),(0,r.kt)("li",{parentName:"ol"},"Fetch subschemas through their ",(0,r.kt)("inlineCode",{parentName:"li"},"_sdl")," query. You ",(0,r.kt)("em",{parentName:"li"},"cannot")," introspect custom directives, so you must use a custom query that provides the complete annotated type definitions string.")),(0,r.kt)("h2",{id:"recipes"},"Recipes"),(0,r.kt)("h3",{id:"picked-keys"},"Picked keys"),(0,r.kt)("p",null,"The simplest merge pattern picks a key field from origin objects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type User {\n  id: ID!\n}\n\ntype Product {\n  upc: ID!\n}\n\ntype Query {\n  user(id: ID!): User @merge(keyField: "id")\n  products(upcs: [ID!]!): [Product]! @merge(keyField: "upc")\n}\n')),(0,r.kt)("p",null,"Here, the ",(0,r.kt)("inlineCode",{parentName:"p"},"@merge")," directive marks each type's merge query, and its ",(0,r.kt)("inlineCode",{parentName:"p"},"keyField")," argument specifies a field to be picked from each original object as the query argument value. The above SDL translates into the following merge config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"merge: {\n  User: {\n    // single-record query:\n    selectionSet: '{ id }'\n    fieldName: 'user',\n    args: ({ id }) => ({ id }),\n  },\n  Product: {\n    // array query:\n    selectionSet: '{ upc }'\n    fieldName: 'products',\n    key: ({ upc }) => upc,\n    argsFromKeys: (upcs) => ({ upcs }),\n  }\n}\n")),(0,r.kt)("h3",{id:"multiple-arguments"},"Multiple arguments"),(0,r.kt)("p",null,"This pattern configures a merge query that receives multiple arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type User {\n  id: ID!\n}\n\ntype Query {\n  users(ids: [ID!]!, scope: String): [User]! @merge(\n    keyField: "id",\n    keyArg: "ids",\n    additionalArgs: """ scope: "all" """\n  )\n}\n')),(0,r.kt)("p",null,"Because the merger field receives multiple arguments, the ",(0,r.kt)("inlineCode",{parentName:"p"},"keyArg")," parameter is required to specify which argument receives the key(s). The ",(0,r.kt)("inlineCode",{parentName:"p"},"additionalArgs")," parameter may also be used to provide static values for other arguments. The above SDL translates into the following merge config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"merge: {\n  User: {\n    selectionSet: '{ id }'\n    fieldName: 'users',\n    key: ({ id }) => id,\n    argsFromKeys: (ids) => ({ ids, scope: 'all' }),\n  }\n}\n")),(0,r.kt)("h3",{id:"object-keys"},"Object keys"),(0,r.kt)("p",null,"In the absence of a ",(0,r.kt)("inlineCode",{parentName:"p"},"keyField")," for the merge directive to pick, keys will assume the shape of an object with a ",(0,r.kt)("inlineCode",{parentName:"p"},"__typename")," and all fields collected for utilized selectionSets on the type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(selectionSet: "{ upc }") {\n  upc: ID!\n  shippingEstimate: Int @computed(selectionSet: "{ price weight }")\n}\n\nscalar _Key\n\ntype Query {\n  products(keys: [_Key!]!): [Product]! @merge\n}\n')),(0,r.kt)("p",null,"The above SDL specifies a type-level selectionSet using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@key")," directive, and a field-level selectionSet using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@computed")," directive. The ",(0,r.kt)("inlineCode",{parentName:"p"},"@merge")," directive takes no arguments here, and will build object keys with fields collected from all utilized selectionSets. These object keys are passed to the merger field as a custom scalar (here called ",(0,r.kt)("inlineCode",{parentName:"p"},"_Key"),"), or as an ",(0,r.kt)("a",{parentName:"p",href:"#typed-inputs"},"input object"),". This SDL translates into the following merge config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// assume \"pick\" works like the lodash method...\nmerge: {\n  Product: {\n    selectionSet: '{ upc }',\n    computedFields: {\n      shippingEstimate: { selectionSet: '{ price weight }' },\n    },\n    fieldName: 'products',\n    key: (obj) => ({ __typename: 'Product', ...pick(obj, ['upc', 'price', 'weight']) }),\n    argsFromKeys: (keys) => ({ keys }),\n  }\n}\n")),(0,r.kt)("p",null,"Each generated object key will have a ",(0,r.kt)("inlineCode",{parentName:"p"},"__typename")," and all ",(0,r.kt)("em",{parentName:"p"},"utilized")," selectionSet fields on the type. For example, when the ",(0,r.kt)("inlineCode",{parentName:"p"},"shippingEstimate")," field is requested, the resulting object keys will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"[\n  { __typename: 'Product', upc: '1', price: 899, weight: 100 },\n  { __typename: 'Product', upc: '2', price: 1299, weight: 1000 }\n]\n")),(0,r.kt)("p",null,"However, when ",(0,r.kt)("inlineCode",{parentName:"p"},"shippingEstimate")," is NOT requested, the generated object keys will only contain fields from the base selectionSet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"[\n  { __typename: 'Product', upc: '1' },\n  { __typename: 'Product', upc: '2' }\n]\n")),(0,r.kt)("h3",{id:"typed-inputs"},"Typed inputs"),(0,r.kt)("p",null,"Similar to the ",(0,r.kt)("a",{parentName:"p",href:"#object-keys"},"object keys")," discussed above, an input object type may be used in place of a generic scalar to cast object keys with a specific schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(selectionSet: "{ upc }") {\n  upc: ID!\n  shippingEstimate: Int @computed(selectionSet: "{ price weight }")\n}\n\ninput ProductKey {\n  upc: ID!\n  price: Int\n  weight: Int\n}\n\ntype Query {\n  products(keys: [ProductKey!]!): [Product]! @merge\n}\n')),(0,r.kt)("p",null,"This SDL translates into the following merge config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// assume \"pick\" works like the lodash method...\nmerge: {\n  Product: {\n    selectionSet: '{ upc }',\n    computedFields: {\n      shippingEstimate: { selectionSet: '{ price weight }' },\n    },\n    fieldName: 'products',\n    key: (obj) => pick(obj, ['upc', 'price', 'weight']),\n    argsFromKeys: (keys) => ({ keys }),\n  }\n}\n")),(0,r.kt)("p",null,"These typed inputs follow the same behavior as object keys with regards to only including fields from ",(0,r.kt)("em",{parentName:"p"},"utilized")," selectionSets. The resulting objects will only ever include fields whitelisted by their input schema, and are subject to nullability mismatch errors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"[\n  { upc: '1', price: 899, weight: 100 },\n  { upc: '2', price: 1299, weight: 1000 }\n]\n")),(0,r.kt)("h3",{id:"nested-inputs"},"Nested inputs"),(0,r.kt)("p",null,"More advanced cases may need to interface with complex inputs. In these cases, the ",(0,r.kt)("inlineCode",{parentName:"p"},"keyArg")," may specify a namespaced path at which to send the merge key:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(selectionSet: "{ upc }") {\n  upc: ID!\n}\n\ninput ProductKey {\n  upc: ID!\n}\n\ninput ProductInput {\n  keys: [ProductKey!]!\n}\n\ntype Query {\n  products(input: ProductInput): [Product]! @merge(keyArg: "input.keys")\n}\n')),(0,r.kt)("h2",{id:"versioning--release"},"Versioning ","&"," release"),(0,r.kt)("p",null,"Once subschemas and their merge configurations are defined as annotated SDLs, new versions of these documents can be pushed to the gateway to trigger a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/hot-schema-reloading"},'"hot" reload'),"\u2014","or, a reload of the gateway schema without restarting its server."),(0,r.kt)("p",null,"However, pushing untested SDLs directly to the gateway is risky due to the potential for incompatible subschema versions to be mixed. Therefore, a formal versioning, testing, and release strategy is necessary for long-term stability. See the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/versioning-schema-releases"},"handbook's versioning example")," that demonstrates turning a basic Git repo into a schema registry that manages versioning and release."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The general process for zero-downtime rollouts is:")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Compose and test all subschema head versions together to verify their combined stability prior to release."),(0,r.kt)("li",{parentName:"ol"},"Deploy all updated subservice applications while keeping their existing subschema features operational."),(0,r.kt)("li",{parentName:"ol"},"Push all updated subschema SDLs to the gateway as a single cutover."),(0,r.kt)("li",{parentName:"ol"},"Decommission old subservices, and/or outdated subservice features.")))}p.isMDXComponent=!0}}]);