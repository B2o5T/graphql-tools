(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[3770],{5318:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7378);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(n),h=i,u=m["".concat(l,".").concat(h)]||m[h]||d[h]||s;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var c=2;c<s;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7435:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return l},toc:function(){return c},default:function(){return d}});var a=n(9603),i=n(120),s=(n(7378),n(5318)),r=["components"],o={id:"stitch-type-merging",title:"Type merging",sidebar_label:"Type merging"},l={unversionedId:"stitch-type-merging",id:"stitch-type-merging",isDocsHomePage:!1,title:"Type merging",description:"Type merging allows partial definitions of a type to exist in any subschema, all of which are merged into one unified type in the gateway schema. When querying for a merged type, the gateway smartly delegates portions of a request to each relevant subschema in dependency order, and then combines all results for the final return.",source:"@site/docs/stitch-type-merging.md",sourceDirName:".",slug:"/stitch-type-merging",permalink:"/docs/stitch-type-merging",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/stitch-type-merging.md",version:"current",sidebar_label:"Type merging",frontMatter:{id:"stitch-type-merging",title:"Type merging",sidebar_label:"Type merging"},sidebar:"someSidebar",previous:{title:"Combining schemas",permalink:"/docs/stitch-combining-schemas"},next:{title:"Directives SDL",permalink:"/docs/stitch-directives-sdl"}},c=[{value:"Basic example",id:"basic-example",children:[{value:"Types without a database",id:"types-without-a-database",children:[]},{value:"Null records",id:"null-records",children:[]}]},{value:"Merging flow",id:"merging-flow",children:[]},{value:"Batching",id:"batching",children:[]},{value:"Unidirectional merges",id:"unidirectional-merges",children:[]},{value:"Merged interfaces",id:"merged-interfaces",children:[]},{value:"Multiple keys",id:"multiple-keys",children:[]},{value:"Computed fields",id:"computed-fields",children:[]},{value:"Federation services",id:"federation-services",children:[]},{value:"Canonical definitions",id:"canonical-definitions",children:[]},{value:"Type resolvers",id:"type-resolvers",children:[{value:"Wrapped resolvers",id:"wrapped-resolvers",children:[]},{value:"Custom resolvers",id:"custom-resolvers",children:[]}]}],p={toc:c};function d(e){var t=e.components,o=(0,i.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Type merging allows ",(0,s.kt)("em",{parentName:"p"},"partial definitions")," of a type to exist in any subschema, all of which are merged into one unified type in the gateway schema. When querying for a merged type, the gateway smartly delegates portions of a request to each relevant subschema in dependency order, and then combines all results for the final return."),(0,s.kt)("p",null,"Type merging is now the preferred method of including GraphQL types across subschemas, replacing the need for ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-schema-extensions"},"schema extensions")," (though does not preclude their use). To migrate from schema extensions, simply enable type merging and then start replacing extensions one by one with merges."),(0,s.kt)("h2",{id:"basic-example"},"Basic example"),(0,s.kt)("p",null,"Type merging allows each subschema to provide subsets of a type that it has data for. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { makeExecutableSchema } from '@graphql-tools/schema';\nimport { addMocksToSchema } from '@graphql-tools/mock';\n\nlet postsSchema = makeExecutableSchema({\n  typeDefs: `\n    type Post {\n      id: ID!\n      message: String!\n      author: User!\n    }\n\n    type User {\n      id: ID!\n      posts: [Post]!\n    }\n\n    type Query {\n      postById(id: ID!): Post\n      postUserById(id: ID!): User\n    }\n  `,\n});\n\nlet usersSchema = makeExecutableSchema({\n  typeDefs: `\n    type User {\n      id: ID!\n      email: String!\n    }\n\n    type Query {\n      userById(id: ID!): User\n    }\n  `,\n});\n\n// just mock the schemas for now to make them return dummy data\npostsSchema = addMocksToSchema({ schema: postsSchema });\nusersSchema = addMocksToSchema({ schema: usersSchema });\n")),(0,s.kt)("p",null,"Note that both services define a ",(0,s.kt)("em",{parentName:"p"},"different")," ",(0,s.kt)("inlineCode",{parentName:"p"},"User")," type. While the users service manages information about user accounts, the posts service simply provides posts associated with a user ID. Now we just have to configure the ",(0,s.kt)("inlineCode",{parentName:"p"},"User")," type to be merged. Type merging requires a query from each subschema to provide its version of a merged type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { stitchSchemas } from '@graphql-tools/stitch';\n\nconst gatewaySchema = stitchSchemas({\n  subschemas: [\n    {\n      schema: postsSchema,\n      merge: {\n        User: {\n          fieldName: 'postUserById',\n          selectionSet: '{ id }',\n          args: originalObject => ({ id: originalObject.id }),\n        },\n      },\n    },\n    {\n      schema: usersSchema,\n      merge: {\n        User: {\n          fieldName: 'userById',\n          selectionSet: '{ id }',\n          args: originalObject => ({ id: originalObject.id }),\n        },\n      },\n    },\n  ],\n  mergeTypes: true, // << default in v7\n});\n")),(0,s.kt)("p",null,"That's it! Under the subschema config ",(0,s.kt)("inlineCode",{parentName:"p"},"merge")," option, each merged type provides a query for accessing its respective partial type (services without an expression of the type may omit this). The query settings are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"fieldName")," specifies a root field used to request the local type."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"selectionSet")," specifies one or more key fields required from other services to perform this query. Query planning will automatically resolve these fields from other subschemas in dependency order."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"args")," formats the initial object representation into query arguments.")),(0,s.kt)("p",null,"See related ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/type-merging-single-records"},"handbook example")," for a working demonstration of this setup. This JavaScript-based syntax may also be written directly into schema type definitions using the ",(0,s.kt)("inlineCode",{parentName:"p"},"@merge")," directive of the ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-directives-sdl"},"stitching SDL"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},'type User {\n  id: ID!\n  email: String!\n}\n\ntype Query {\n  userById(id: ID!): User @merge(keyField: "id")\n}\n')),(0,s.kt)("p",null,"Regardless of how this merge configuration is written, it allows type merging to smartly resolve a complete ",(0,s.kt)("inlineCode",{parentName:"p"},"User"),", regardless of which service provides the initial representation of it. We now have a combined ",(0,s.kt)("inlineCode",{parentName:"p"},"User")," type in the gateway schema:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},"type User {\n  id: ID!\n  email: String!\n  posts: [Post]!\n}\n")),(0,s.kt)("h3",{id:"types-without-a-database"},"Types without a database"),(0,s.kt)("p",null,"It's logical to assume that each ",(0,s.kt)("inlineCode",{parentName:"p"},"postUserById")," query has a backing database table used to lookup the requested user ID. However, this is frequently not the case. Here's a simple example that demonstrates how ",(0,s.kt)("inlineCode",{parentName:"p"},"User.posts")," can be resolved without the posts service having any formal database concept of a User:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { makeExecutableSchema } from '@graphql-tools/schema';\n\nconst postsData = [\n  { id: '1', message: 'Hello', authorId: '7' },\n  { id: '2', message: 'Goodbye', authorId: '5' },\n];\n\nconst postsSchema = makeExecutableSchema({\n  typeDefs: `\n    type Post {\n      id: ID!\n      message: String!\n      author: User!\n    }\n\n    type User {\n      id: ID!\n      posts: [Post]!\n    }\n\n    type Query {\n      postById(id: ID!): Post\n      postUserById(id: ID!): User\n    }\n  `,\n  resolvers: {\n    Query: {\n      postById: (root, { id }) => postsData.find(post => post.id === id),\n      postUserById: (root, { id }) => ({ id }),\n    },\n    User: {\n      posts(user) {\n        return postsData.filter(post => post.authorId === user.id);\n      },\n    },\n  },\n});\n")),(0,s.kt)("p",null,"In this example, the ",(0,s.kt)("inlineCode",{parentName:"p"},"postUserById")," resolver simply converts a submitted user ID into stub record that gets resolved as the local ",(0,s.kt)("inlineCode",{parentName:"p"},"User")," type."),(0,s.kt)("h3",{id:"null-records"},"Null records"),(0,s.kt)("p",null,"The above example will always resolve a stubbed ",(0,s.kt)("inlineCode",{parentName:"p"},"User")," record for ",(0,s.kt)("em",{parentName:"p"},"any")," requested ID. For example, requesting ID ",(0,s.kt)("inlineCode",{parentName:"p"},"7")," (which has no associated posts) would return:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"{ id: '7', posts: [] }\n")),(0,s.kt)("p",null,"This fabricated record fulfills the not-null requirement of the ",(0,s.kt)("inlineCode",{parentName:"p"},"posts:[Post]!")," field. However, it also makes the posts service awkwardly responsible for data it knows only by omission. A cleaner solution may be to loosen schema nullability down to ",(0,s.kt)("inlineCode",{parentName:"p"},"posts:[Post]"),", and then return ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," for unknown user IDs without associated posts. Null is a valid mergable object as long as the unique fields it fulfills are nullable. See the related ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/type-merging-nullables"},"handbook example")," for a detailed explanation."),(0,s.kt)("h2",{id:"merging-flow"},"Merging flow"),(0,s.kt)("p",null,"To better understand the flow of merged object calls, let's break down the ",(0,s.kt)("a",{parentName:"p",href:"#basic-example"},"basic example")," above:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Schema Stitching flow",src:n(6490).Z})),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"A request is submitted to the gateway schema that selects fields from multiple subschemas."),(0,s.kt)("li",{parentName:"ol"},"The gateway fetches the resource that was ",(0,s.kt)("strong",{parentName:"li"},"explicitly")," requested (",(0,s.kt)("inlineCode",{parentName:"li"},"userById"),"), known as the ",(0,s.kt)("em",{parentName:"li"},"original object"),". This subquery is filtered to match its subschema, and adds the ",(0,s.kt)("inlineCode",{parentName:"li"},"selectionSet")," of other subschemas that must ",(0,s.kt)("strong",{parentName:"li"},"implicitly")," provide data for the request."),(0,s.kt)("li",{parentName:"ol"},"The original object returns with fields requested by the user and those necessary to query other subschemas, per their ",(0,s.kt)("inlineCode",{parentName:"li"},"selectionSet"),"."),(0,s.kt)("li",{parentName:"ol"},"Merge config builds subsequent queries for ",(0,s.kt)("em",{parentName:"li"},"merger objects")," that will provide missing data. These subqueries are built using ",(0,s.kt)("inlineCode",{parentName:"li"},"fieldName")," with arguments derived from the original object."),(0,s.kt)("li",{parentName:"ol"},"Subqueries for merger objects are initiated; again filtering each query to match its intended subschema, and adding the ",(0,s.kt)("inlineCode",{parentName:"li"},"selectionSet")," of other subschemas","\u2020",". Merger queries run in parallel when possible."),(0,s.kt)("li",{parentName:"ol"},"Merger objects are returned with additional fields requested by the user and those necessary to query other subschemas, per their ",(0,s.kt)("inlineCode",{parentName:"li"},"selectionSet"),"\u2020","."),(0,s.kt)("li",{parentName:"ol"},"Merger objects are applied to the original object, building an aggregate result."),(0,s.kt)("li",{parentName:"ol"},"The gateway responds with the original query selection applied to the aggregate merge result.")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"\u2020"," Note: merger subqueries may still collect unique ",(0,s.kt)("inlineCode",{parentName:"em"},"selectionSet")," fields. Given subschemas A, B, and C, it's perfectly valid for schema C to specify fields from both A and B in its selection set. When this happens, resolving C will simply be deferred until the merger of A and B can be provided as its original object.")),(0,s.kt)("h2",{id:"batching"},"Batching"),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"#basic-example"},"basic example")," above queries for a single record each time it performs a merge, which is suboptimal when merging arrays of objects. Instead, we should batch many record requests together using array queries that may fetch many partials at once, the schema for which would be:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},"postUsersByIds(ids: [ID!]!): [User]!\nusersByIds(ids: [ID!]!): [User]!\n")),(0,s.kt)("p",null,"Once a service provides an array query for a merged type, batching may be enabled by adding a ",(0,s.kt)("inlineCode",{parentName:"p"},"key")," method that picks a key from each partial record. The ",(0,s.kt)("inlineCode",{parentName:"p"},"argsFromKeys")," method then transforms the list of picked keys into query arguments:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { stitchSchemas } from '@graphql-tools/stitch';\n\nconst gatewaySchema = stitchSchemas({\n  subschemas: [\n    {\n      schema: postsSchema,\n      merge: {\n        User: {\n          fieldName: 'postUsersByIds',\n          selectionSet: '{ id }',\n          key: ({ id }) => id,\n          argsFromKeys: ids => ({ ids }),\n        },\n      },\n    },\n    {\n      schema: usersSchema,\n      merge: {\n        User: {\n          fieldName: 'usersByIds',\n          selectionSet: '{ id }',\n          key: ({ id }) => id,\n          argsFromKeys: ids => ({ ids }),\n        },\n      },\n    },\n  ],\n});\n")),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"valuesFromResults")," method may also be provided to map the raw query result into the batched set. With this array optimization in place, we'll now only perform one query ",(0,s.kt)("em",{parentName:"p"},"per merged field")," (versus per record). However, requesting multiple merged fields will still perform a query each. To optimize this further, we can enable ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/wiki/Batching-Arrays-and-Queries#what-is-query-batching"},"query batching"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"{\n  schema: postsSchema,\n  batch: true,\n  batchingOptions: { ... },\n  merge: {\n    User: {\n      fieldName: 'postUsersByIds',\n      selectionSet: '{ id }',\n      key: ({ id }) => id,\n      argsFromKeys: (ids) => ({ ids }),\n    }\n  }\n}\n")),(0,s.kt)("p",null,"Query batching will collect all queries made during an execution cycle and combine them into a single GraphQL operation to send to the subschema. This consolidates networking with remote services, and improves database batching within the underlying service implementation. You may customize query batching behavior with ",(0,s.kt)("inlineCode",{parentName:"p"},"batchingOptions"),"\u2014","this is particularly useful for providing ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/graphql/dataloader#new-dataloaderbatchloadfn--options"},"DataLoader options"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"batchingOptions?: {\n  dataLoaderOptions?: DataLoader.Options<K, V, C>;\n  extensionsReducer?: (mergedExtensions: Record<string, any>, executionParams: ExecutionParams) => Record<string, any>;\n}\n")),(0,s.kt)("p",null,"Using both array batching and query batching together is recommended, and should flatten transactional costs down to one query per subservice per generation of data. See related ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/type-merging-arrays"},"handbook example")," for a working demonstration of this process."),(0,s.kt)("h2",{id:"unidirectional-merges"},"Unidirectional merges"),(0,s.kt)("p",null,"Type merging allows services to provide the bare minimum of fields they possess data for","\u2014","and this is frequently nothing but an ID. For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { makeExecutableSchema } from '@graphql-tools/schema';\n\nlet postsSchema = makeExecutableSchema({\n  typeDefs: `\n    type Post {\n      id: ID!\n      message: String!\n      author: User!\n    }\n\n    # ID-only stub...\n    type User {\n      id: ID!\n    }\n\n    type Query {\n      postById(id: ID!): Post\n    }\n  `,\n});\n\nlet usersSchema = makeExecutableSchema({\n  typeDefs: `\n    type User {\n      id: ID!\n      email: String!\n    }\n\n    type Query {\n      usersByIds(ids: [ID!]!): [User]!\n    }\n  `,\n});\n")),(0,s.kt)("p",null,"When a stub type like the one above includes no unique fields beyond a key shared across services, then the type may be considered ",(0,s.kt)("em",{parentName:"p"},"unidirectional")," to the service","\u2014","that is, the service holds no unique data that would require an inbound request to fetch it. In these cases, ",(0,s.kt)("inlineCode",{parentName:"p"},"merge")," config may be omitted entirely for the stub type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const gatewaySchema = stitchSchemas({\n  subschemas: [\n    {\n      schema: postsSchema,\n    },\n    {\n      schema: usersSchema,\n      merge: {\n        User: {\n          selectionSet: '{ id }',\n          fieldName: 'usersByIds',\n          key: ({ id }) => id,\n          argsFromKeys: ids => ({ ids }),\n        },\n      },\n    },\n  ],\n});\n")),(0,s.kt)("p",null,"Stubbed types are quick and easy to setup and effectively work as automatic ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-schema-extensions"},"schema extensions")," (in fact, you might not need extensions). A stubbed type may always be expanded with additional service-specific fields (see the ",(0,s.kt)("a",{parentName:"p",href:"#basic-example"},"basic example"),"), however it requires a query in ",(0,s.kt)("inlineCode",{parentName:"p"},"merge")," config as soon as it offers unique data."),(0,s.kt)("h2",{id:"merged-interfaces"},"Merged interfaces"),(0,s.kt)("p",null,"Type merging will automatically consolidate interfaces of the same name across subschemas, allowing each subschema to contribute fields. This is extremely useful when the complete interface of fields is not available in all subschemas","\u2014","each subschema simply provides the minimum set of fields that it contains:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const postsSchema = makeExecutableSchema({\n  typeDefs: `\n    interface HomepageSlot {\n      id: ID!\n      title: String!\n      url: URL!\n    }\n\n    type Post implements HomepageSlot {\n      id: ID!\n      title: String!\n      url: URL!\n    }\n  `,\n});\n\nconst layoutsSchema = makeExecutableSchema({\n  typeDefs: `\n    interface HomepageSlot {\n      id: ID!\n    }\n\n    type Post implements HomepageSlot {\n      id: ID!\n    }\n\n    type Section implements HomepageSlot {\n      id: ID!\n      title: String!\n      url: URL!\n      posts: [Post!]!\n    }\n\n    type Homepage {\n      slots: [HomepageSlot]!\n    }\n  `,\n});\n")),(0,s.kt)("p",null,"In the above, both ",(0,s.kt)("inlineCode",{parentName:"p"},"Post")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Section")," will have a common interface of ",(0,s.kt)("inlineCode",{parentName:"p"},"{ id title url }")," in the gateway schema. The difference in interface fields between the gateway schema and the layouts subschema will automatically be expanded into typed fragments for compatibility. See related ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/type-merging-interfaces"},"handbook example")," for a working demonstration."),(0,s.kt)("h2",{id:"multiple-keys"},"Multiple keys"),(0,s.kt)("p",null,"Merged types may define multiple key fields across services that join through a central service, for example:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Catalog service: ",(0,s.kt)("inlineCode",{parentName:"li"},"type Product { upc }")),(0,s.kt)("li",{parentName:"ul"},"Vendors service: ",(0,s.kt)("inlineCode",{parentName:"li"},"type Product { upc id }")),(0,s.kt)("li",{parentName:"ul"},"Reviews service: ",(0,s.kt)("inlineCode",{parentName:"li"},"type Product { id }"))),(0,s.kt)("p",null,"Given this graph, the Vendors service must provide lookups for its ",(0,s.kt)("inlineCode",{parentName:"p"},"Product")," type by either ",(0,s.kt)("inlineCode",{parentName:"p"},"upc")," ",(0,s.kt)("em",{parentName:"p"},"or")," ",(0,s.kt)("inlineCode",{parentName:"p"},"id")," to enable all possible traversals. These multiple pathways can be configured as ",(0,s.kt)("inlineCode",{parentName:"p"},"entryPoints"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { stitchSchemas } from '@graphql-tools/stitch';\n\nconst gatewaySchema = stitchSchemas({\n  subschemas: [\n    {\n      schema: catalogSchema,\n      merge: {\n        Product: {\n          selectionSet: '{ upc }',\n          fieldName: 'productByUpc',\n          args: upc => ({ upc }),\n        },\n      },\n    },\n    {\n      schema: vendorsSchema,\n      merge: {\n        Product: {\n          // Entry points for each key format:\n          entryPoints: [\n            {\n              selectionSet: '{ upc }',\n              fieldName: 'productByUpc',\n              args: upc => ({ upc }),\n            },\n            {\n              selectionSet: '{ id }',\n              fieldName: 'productById',\n              args: id => ({ id }),\n            },\n          ],\n        },\n      },\n    },\n    {\n      schema: reviewsSchema,\n      merge: {\n        Product: {\n          selectionSet: '{ id }',\n          fieldName: 'productById',\n          args: id => ({ id }),\n        },\n      },\n    },\n  ],\n});\n")),(0,s.kt)("p",null,"Note that the ",(0,s.kt)("inlineCode",{parentName:"p"},"entryPoints")," option replaces a merged type's base ",(0,s.kt)("inlineCode",{parentName:"p"},"selectionSet")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"fieldName"),". This configuration is not currently possible with SDL directives, though it may be statically configured alongside of SDL parsing."),(0,s.kt)("h2",{id:"computed-fields"},"Computed fields"),(0,s.kt)("p",null,"APIs may leverage the gateway layer to transport field dependencies from one subservice to another while resolving data. This is useful when a field in one subschema requires one or more fields from other subschemas to be resolved, as described in the ",(0,s.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/apollo-server/federation/federation-spec/#requires"},"federation spec"),". For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { makeExecutableSchema } from '@graphql-tools/schema';\nimport { stitchSchemas } from '@graphql-tools/stitch';\n\nconst productsSchema = makeExecutableSchema({\n  typeDefs: `\n    type Product {\n      id: ID!\n      price: Float!\n      weight: Int!\n    }\n\n    type Query {\n      productsByIds(ids: [ID!]!): [Product]!\n    }\n  `,\n  resolvers: { ... },\n});\n\nconst storefrontsSchema = makeExecutableSchema({\n  typeDefs: `\n    directive @computed(selectionSet: String!) on FIELD_DEFINITION\n\n    type Storefront {\n      id: ID!\n      availableProducts: [Product]!\n    }\n\n    type Product {\n      id: ID!\n      shippingEstimate: Float! @computed(selectionSet: \"{ price weight }\")\n      deliveryService: String! @computed(selectionSet: \"{ weight }\")\n    }\n\n    input ProductInput {\n      id: ID!\n      price: Float\n      weight: Int\n    }\n\n    type Query {\n      storefront(id: ID!): Storefront\n      _products(representations: [ProductInput!]!): [Product]!\n    }\n  `,\n  resolvers: {\n    Query: {\n      storefront: (root, { id }) => ({ id, availableProducts: [{ id: '23' }] }),\n      _products: (root, { representations }) => representations,\n    },\n    Product: {\n      shippingEstimate: (rep) => rep.price > 50 ? 0 : rep.weight / 2,\n      deliveryService: (rep) => rep.weight > 50 ? 'FREIGHT' : 'POSTAL',\n    }\n  }\n});\n\nconst gatewaySchema = stitchSchemas({\n  subschemas: [{\n    schema: productsSchema,\n    merge: {\n      Product: {\n        selectionSet: '{ id }',\n        fieldName: 'productsByIds',\n        key: ({ id }) => id,\n        args: (ids) => ({ ids }),\n      }\n    }\n  }, {\n    schema: storefrontsSchema,\n    merge: {\n      Product: {\n        selectionSet: '{ id }',\n        fieldName: '_products',\n        key: ({ id, price, weight }) => ({ id, price, weight }),\n        argsFromKeys: (representations) => ({ representations }),\n      }\n    }\n  }]\n});\n")),(0,s.kt)("p",null,"In the above, the ",(0,s.kt)("inlineCode",{parentName:"p"},"shippingEstimate")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"deliveryService")," fields are marked with ",(0,s.kt)("inlineCode",{parentName:"p"},"@computed")," directives (see ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-directives-sdl"},"stitching directives SDL"),"), which specify additional ",(0,s.kt)("em",{parentName:"p"},"field-level dependencies")," required to resolve these specific fields beyond the ",(0,s.kt)("inlineCode",{parentName:"p"},"Product")," type's base selection set. When a computed field appears in a query, the gateway will collect that field's dependencies from other subschemas so they may be sent as input with the request for the computed field(s)."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"@computed")," SDL directive is a convenience syntax for static configuration that can be written as:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"{\n  schema: storefrontsSchema,\n  merge: {\n    Product: {\n      selectionSet: '{ id }',\n      fields: {\n        shippingEstimate: {\n          selectionSet: '{ price weight }',\n          computed: true,\n        },\n        deliveryService: {\n          selectionSet: '{ weight }',\n          computed: true,\n        },\n      },\n      fieldName: '_products',\n      key: ({ id, price, weight }) => ({ id, price, weight }),\n      argsFromKeys: (representations) => ({ representations }),\n    }\n  }\n}\n")),(0,s.kt)("p",null,"A field-level ",(0,s.kt)("inlineCode",{parentName:"p"},"selectionSet")," specifies field dependencies while the ",(0,s.kt)("inlineCode",{parentName:"p"},"computed")," setting structures the field in a way that assures it is always selected with this data provided. The ",(0,s.kt)("inlineCode",{parentName:"p"},"selectionSet")," is intentionally generic to support possible future uses."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Implementation note:")," to assure that computed fields are always requested directly by the gateway with their dependencies provided, computed and non-computed fields of a type in the same subservice are automatically split apart into separate schemas. This means that computed and non-computed fields may require separate resolution steps. You may enable ",(0,s.kt)("a",{parentName:"p",href:"#batching"},"query batching")," to consolidate requests whenever possible.")),(0,s.kt)("p",null,"The main disadvantage of computed fields is that they cannot be resolved independently from the stitched gateway. Tolerance for this subservice inconsistency is largely dependent on your own service architecture. An imperfect solution is to deprecate all computed fields within a subschema, and then normalize their behavior in the gateway schema with a ",(0,s.kt)("a",{parentName:"p",href:"/docs/schema-wrapping#grooming"},(0,s.kt)("inlineCode",{parentName:"a"},"RemoveObjectFieldDeprecations"))," transform. See related ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/computed-fields"},"handbook example"),"."),(0,s.kt)("h2",{id:"federation-services"},"Federation services"),(0,s.kt)("p",null,"If you're familiar with ",(0,s.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/apollo-server/federation/introduction/"},"Apollo Federation"),", then you may notice that the above pattern of computed fields looks similar to the ",(0,s.kt)("inlineCode",{parentName:"p"},"_entities")," service design of the ",(0,s.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/apollo-server/federation/federation-spec/"},"Apollo Federation specification"),". Federation resources may be included in a stitched gateway; this comes in handy when integrating with third-party services or in the process of a migration. See related ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/gmac/schema-stitching-handbook/tree/master/federation-services"},"handbook example")," for more information."),(0,s.kt)("h2",{id:"canonical-definitions"},"Canonical definitions"),(0,s.kt)("p",null,"Managing the gateway schema definition of each type and field becomes challenging as the same type names are introduced across subschemas. By default, the final definition of each named GraphQL element found in the stitched ",(0,s.kt)("inlineCode",{parentName:"p"},"subschemas")," array provides its gateway definition. However, preferred definitions may be marked as ",(0,s.kt)("inlineCode",{parentName:"p"},"canonical")," to receive this final priority. Canonical definitions provide:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"an element's description (doc string)."),(0,s.kt)("li",{parentName:"ul"},"an element's final directive values."),(0,s.kt)("li",{parentName:"ul"},"a field's final nullability, arguments, and deprecation reason."),(0,s.kt)("li",{parentName:"ul"},"a root field's default delegation target.")),(0,s.kt)("p",null,"The following example uses ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-directives-sdl"},"stitching directives")," to mark preferred subschema elements as ",(0,s.kt)("inlineCode",{parentName:"p"},"@canonical"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},'# --- Users schema ---\n\n"Represents an authenticated user"\ntype User @canonical {\n  "The primary key of this user record"\n  id: ID! @mydir(schema: "users")\n  "other description"\n  field: String!\n}\n\ntype Query {\n  "Users schema definition"\n  user(id: ID!): User @canonical\n}\n\n# --- Posts schema ---\n\ntype Post {\n  id: ID!\n}\n\n"other description"\ntype User {\n  "other description"\n  id: ID! @mydir(schema: "posts")\n  "The canonical field description"\n  field: String @canonical\n  "Posts authored by this user"\n  posts: [Post!]\n}\n\ntype Query {\n  "Posts schema definition"\n  user(id: ID!): User\n}\n')),(0,s.kt)("p",null,"The above ASTs will merge into the following gateway schema definition, and the root ",(0,s.kt)("inlineCode",{parentName:"p"},"user")," field will proxy the Users subschema by default:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},'# --- Gateway schema ---\n\n"Represents an authenticated user"\ntype User {\n  "The primary key of this user record"\n  id: ID! @mydir(schema: "users")\n  "The canonical field description"\n  field: String\n  "Posts authored by this user"\n  posts: [Post!]\n}\n\ntype Query {\n  "Users schema definition"\n  user(id: ID!): User\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Types")," marked as canonical will provide their definition ",(0,s.kt)("em",{parentName:"li"},"and that of all of their fields")," to the combined gateway schema."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Fields")," marked as canonical will override those of a canonical type."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Root fields")," marked as canonical will specify which subschema the field proxies by default for new queries entering the graph.")),(0,s.kt)("p",null,"Only one of any given type or field may be made canonical. Fields that are unique to one service (such as ",(0,s.kt)("inlineCode",{parentName:"p"},"User.posts")," above) have no competing definition so are canonical by default."),(0,s.kt)("p",null,"The above SDL directives can also be written as static configuration:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { stitchSchemas } from '@graphql-tools/stitch';\n\nconst gatewaySchema = stitchSchemas({\n  subschemas: [\n    {\n      schema: usersSchema,\n      merge: {\n        User: {\n          // ...\n          canonical: true,\n        },\n        Query: {\n          fields: {\n            user: { canonical: true },\n          },\n        },\n      },\n    },\n    {\n      schema: postsSchema,\n      merge: {\n        User: {\n          // ...\n          fields: {\n            email: { canonical: true },\n          },\n        },\n      },\n    },\n  ],\n});\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Implementation note:")," canonical settings are ",(0,s.kt)("em",{parentName:"p"},"only")," used for building the combined gateway schema definition and defaulting root field targets; otherwise, they are given no special priority in runtime query planning (which always selects necessary fields from as few subschemas as possible). You may override the assembly of canonical definitions using ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-combining-schemas#automatic-merge"},(0,s.kt)("inlineCode",{parentName:"a"},"typeMergingOptions")),".")),(0,s.kt)("h2",{id:"type-resolvers"},"Type resolvers"),(0,s.kt)("p",null,"Similar to how GraphQL objects implement field resolvers, merging implements type resolvers for fetching and merging partial types. These resolvers are configured automatically, though advanced use cases may want to customize some or all of their default behavior. Merged type resolver methods are of type ",(0,s.kt)("inlineCode",{parentName:"p"},"MergedTypeResolver"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"export type MergedTypeResolver = (\n  originalObject: any, // initial object being merged onto\n  context: Record<string, any>, // gateway request context\n  info: GraphQLResolveInfo, // gateway request info\n  subschema: SubschemaConfig, // target subschema configuration\n  selectionSet: SelectionSetNode, // target subschema selection\n  key?: any // the batch key being requested\n) => any;\n")),(0,s.kt)("h3",{id:"wrapped-resolvers"},"Wrapped resolvers"),(0,s.kt)("p",null,"Frequently we want to augment type resolution without fundamentally changing its behavior. This can be done by building a default resolver function, and then wrapping it in a custom implementation. For example, adding ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/msiebuhr/node-statsd-client"},"statsd instrumentation")," might look like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { createMergedTypeResolver, stitchSchemas } from '@graphql-tools/stitch';\nimport { SDC } from 'statsd-client';\n\nconst statsd = new SDC({ ... });\n\nfunction createInstrumentedMergedTypeResolver(resolverOptions) {\n  const defaultResolve = createMergedTypeResolver(resolverOptions);\n  return async (obj, ctx, info, cfg, sel, key) => {\n    const startTime = process.hrtime();\n    try {\n      return await defaultResolve(obj, ctx, info, cfg, sel, key);\n    } finally {\n      statsd.timing(info.path.join('.'), process.hrtime(startTime));\n    }\n  };\n}\n\nconst schema = stitchSchemas({\n  subschemas: [{\n    schema: widgetsSchema,\n    merge: {\n      Widget: {\n        selectionSet: '{ id }',\n        key: ({ id }) => id,\n        resolve: createInstrumentedMergedTypeResolver({\n          fieldName: 'widgets',\n          argsFromKeys: (ids) => ({ ids }),\n        }),\n      }\n    }\n  }]\n});\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"createMergedTypeResolver")," helper accepts a subset of options that would otherwise be included directly on merged type configuration: ",(0,s.kt)("inlineCode",{parentName:"p"},"fieldName"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"args"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"argsFromKeys"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"valuesFromResults"),". A default MergedTypeResolver function is returned, and may be wrapped with additional behavior and then assigned as a custom ",(0,s.kt)("inlineCode",{parentName:"p"},"resolve")," option for the type."),(0,s.kt)("h3",{id:"custom-resolvers"},"Custom resolvers"),(0,s.kt)("p",null,"Alternatively, you may provide completely custom resolver implementations for fetching types in non-standard ways. For example, fetching a merged type from a REST API might look like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"{\n  schema: widgetsSchema,\n  merge: {\n    Widget: {\n      selectionSet: '{ id }',\n      resolve: async (originalObject) => {\n        const mergeObject = await fetchViaREST(originalObject.id);\n        return { ...originalObject, ...mergeObject };\n      }\n    }\n  }\n}\n")),(0,s.kt)("p",null,"When incorporating plain objects, always extend the provided ",(0,s.kt)("inlineCode",{parentName:"p"},"originalObject")," to retain internal merge configuration. You may also return direct calls to ",(0,s.kt)("inlineCode",{parentName:"p"},"delegateToSchema")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"batchDelegateToSchema")," (as described for ",(0,s.kt)("a",{parentName:"p",href:"/docs/stitch-schema-extensions#basic-example"},"schema extensions"),"), however","\u2014","always provide these delegation methods with a ",(0,s.kt)("inlineCode",{parentName:"p"},"skipTypeMerging: true")," option to prevent infinite recursion."))}d.isMDXComponent=!0},6490:function(e,t,n){"use strict";t.Z=n.p+"assets/images/stitching-flow-03e3b647f107414635db52ae8cda8270.png"}}]);