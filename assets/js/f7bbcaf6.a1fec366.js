(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[7492],{5318:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),h=p(n),d=a,m=h["".concat(s,".").concat(d)]||h[d]||u[d]||o;return n?r.createElement(m,l(l({ref:t},c),{},{components:n})):r.createElement(m,l({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3464:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return i},toc:function(){return s},default:function(){return c}});var r=n(9603),a=n(120),o=(n(7378),n(5318)),l={id:"resolvers",title:"Resolvers",description:"Writing resolvers with graphql-tools"},i={unversionedId:"resolvers",id:"resolvers",isDocsHomePage:!1,title:"Resolvers",description:"Writing resolvers with graphql-tools",source:"@site/docs/resolvers.md",sourceDirName:".",slug:"/resolvers",permalink:"/docs/resolvers",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/resolvers.md",version:"current",frontMatter:{id:"resolvers",title:"Resolvers",description:"Writing resolvers with graphql-tools"},sidebar:"someSidebar",previous:{title:"Executable schemas",permalink:"/docs/generate-schema"},next:{title:"Resolvers composition",permalink:"/docs/resolvers-composition"}},s=[{value:"Resolver map",id:"resolver-map",children:[]},{value:"Resolver function signature",id:"resolver-function-signature",children:[{value:"Resolver result format",id:"resolver-result-format",children:[]},{value:"Resolver obj argument",id:"resolver-obj-argument",children:[]},{value:"Default resolver",id:"default-resolver",children:[]},{value:"Class method resolvers",id:"class-method-resolvers",children:[]}]},{value:"Unions and interfaces",id:"unions-and-interfaces",children:[]},{value:"API",id:"api",children:[{value:"addResolversToSchema({ schema, resolvers, resolverValidationOptions?, inheritResolversFromInterfaces? })",id:"addresolverstoschema-schema-resolvers-resolvervalidationoptions-inheritresolversfrominterfaces-",children:[]},{value:"addSchemaLevelResolver(schema, rootResolveFunction)",id:"addschemalevelresolverschema-rootresolvefunction",children:[]}]}],p={toc:s};function c(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"When using ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql-tools"),", you define your field resolvers separately from the schema. Since the schema already describes all of the fields, arguments, and result types, the only thing left is a collection of functions that are called to actually execute these fields."),(0,o.kt)("p",null,"Keep in mind that GraphQL resolvers can return ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"},"promises"),". In fact, most resolvers that do real work - for example fetching data from a database or a REST API - will return a promise. If you\u2019re not familiar with promises, here\u2019s ",(0,o.kt)("a",{parentName:"p",href:"https://scotch.io/tutorials/javascript-promises-for-dummies"},"a brief overview"),"."),(0,o.kt)("h2",{id:"resolver-map"},"Resolver map"),(0,o.kt)("p",null,'In order to respond to queries, a schema needs to have resolvers for all fields. Resolvers are per field functions that are given a parent object, arguments, and the execution context, and are responsible for returning a result for that field. Resolvers cannot be included in the GraphQL schema language, so they must be added separately. The collection of resolvers is called the "resolver map".'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"resolverMap")," object (",(0,o.kt)("inlineCode",{parentName:"p"},"IResolvers"),") should have a map of resolvers for each relevant GraphQL Object Type. The following is an example of a valid ",(0,o.kt)("inlineCode",{parentName:"p"},"resolverMap")," object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const resolverMap = {\n  Query: {\n    author(obj, args, context, info) {\n      return find(authors, { id: args.id });\n    },\n  },\n  Author: {\n    posts(author) {\n      return filter(posts, { authorId: author.id });\n    },\n  },\n};\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: If you are using mocking, the ",(0,o.kt)("inlineCode",{parentName:"p"},"preserveResolvers")," argument of ",(0,o.kt)("a",{parentName:"p",href:"/docs/mocking/#addmockstoschema"},(0,o.kt)("inlineCode",{parentName:"a"},"addMocksToSchema"))," must be set to ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if you don't want your resolvers to be overwritten by mock resolvers.")),(0,o.kt)("p",null,"Note that you don't have to put all of your resolvers in one object. Refer to the ",(0,o.kt)("a",{parentName:"p",href:"/docs/merge-resolvers/"},'"merging resolvers"')," section to learn how to combine multiple resolver maps into one."),(0,o.kt)("h2",{id:"resolver-function-signature"},"Resolver function signature"),(0,o.kt)("p",null,"Every resolver in a GraphQL.js schema accepts four positional arguments:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"fieldName(obj, args, context, info) { result }\n")),(0,o.kt)("p",null,"These arguments have the following meanings and conventional names:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"obj"),": The object that contains the result returned from the resolver on the parent field, or, in the case of a top-level ",(0,o.kt)("inlineCode",{parentName:"li"},"Query")," field, the ",(0,o.kt)("inlineCode",{parentName:"li"},"rootValue")," passed from the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/graphql/express-graphql#options/"},"server configuration"),". This argument enables the nested nature of GraphQL queries."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"args"),": An object with the arguments passed into the field in the query. For example, if the field was called with ",(0,o.kt)("inlineCode",{parentName:"li"},'author(name: "Ada")'),", the ",(0,o.kt)("inlineCode",{parentName:"li"},"args")," object would be: ",(0,o.kt)("inlineCode",{parentName:"li"},'{ "name": "Ada" }'),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"context"),": This is an object shared by all resolvers in a particular query, and is used to contain per-request state, including authentication information, dataloader instances, and anything else that should be taken into account when resolving the query. If you're using ",(0,o.kt)("inlineCode",{parentName:"li"},"express-graphql"),", ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/graphql/express-graphql#options"},"read about how to set the context in the setup documentation"),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"info"),": This argument should only be used in advanced cases, but it contains information about the execution state of the query, including the field name, path to the field from the root, and more. It's only documented in the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/graphql/graphql-js/blob/c82ff68f52722c20f10da69c9e50a030a1f218ae/src/type/definition.js#L489-L500"},"GraphQL.js source code"),".")),(0,o.kt)("h3",{id:"resolver-result-format"},"Resolver result format"),(0,o.kt)("p",null,"Resolvers in GraphQL can return different kinds of results which are treated differently:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"null")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"undefined")," - this indicates the object could not be found. If your schema says that field is ",(0,o.kt)("em",{parentName:"li"},"nullable"),", then the result will have a ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," value at that position. If the field is ",(0,o.kt)("inlineCode",{parentName:"li"},"non-null"),', the result will "bubble up" to the nearest nullable field and that result will be set to ',(0,o.kt)("inlineCode",{parentName:"li"},"null"),". This is to ensure that the API consumer never gets a ",(0,o.kt)("inlineCode",{parentName:"li"},"null")," value when they were expecting a result."),(0,o.kt)("li",{parentName:"ol"},"An array - this is only valid if the schema indicates that the result of a field should be a list. The sub-selection of the query will run once for every item in this array."),(0,o.kt)("li",{parentName:"ol"},"A promise - resolvers often do asynchronous actions like fetching from a database or backend API, so they can return promises. This can be combined with arrays, so a resolver can return:",(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"A promise that resolves an array"),(0,o.kt)("li",{parentName:"ol"},"An array of promises"))),(0,o.kt)("li",{parentName:"ol"},"A scalar or object value - a resolver can also return any other kind of value, which doesn't have any special meaning but is simply passed down into any nested resolvers, as described in the next section.")),(0,o.kt)("h3",{id:"resolver-obj-argument"},"Resolver obj argument"),(0,o.kt)("p",null,"The first argument to every resolver, ",(0,o.kt)("inlineCode",{parentName:"p"},"obj"),", can be a bit confusing at first, but it makes sense when you consider what a GraphQL query looks like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"query {\n  getAuthor(id: 5){\n    name\n    posts {\n      title\n      author {\n        name # this will be the same as the name above\n      }\n    }\n  }\n}\n")),(0,o.kt)("p",null,"You can think of every GraphQL query as a tree of function calls, as explained in detail in the ",(0,o.kt)("a",{parentName:"p",href:"https://blog.apollographql.com/graphql-explained-5844742f195e#.fq5jjdw7t"},"GraphQL explained blog post"),". So the ",(0,o.kt)("inlineCode",{parentName:"p"},"obj")," contains the result of parent resolver, in this case:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"obj")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"Query.getAuthor")," will be whatever the server configuration passed for ",(0,o.kt)("inlineCode",{parentName:"li"},"rootValue"),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"obj")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"Author.name")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Author.posts")," will be the result from ",(0,o.kt)("inlineCode",{parentName:"li"},"getAuthor"),", likely an Author object from the backend."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"obj")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"Post.title")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Post.author")," will be one item from the ",(0,o.kt)("inlineCode",{parentName:"li"},"posts")," result array."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"obj")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"Author.name")," is the result from the above ",(0,o.kt)("inlineCode",{parentName:"li"},"Post.author")," call.")),(0,o.kt)("p",null,"Basically, it's just every resolver function being called in a nested way according to the layout of the query."),(0,o.kt)("h3",{id:"default-resolver"},"Default resolver"),(0,o.kt)("p",null,"You don't need to specify resolvers for ",(0,o.kt)("em",{parentName:"p"},"every")," type in your schema. If you don't specify a resolver, GraphQL.js falls back to a default one, which does the following:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Returns a property from ",(0,o.kt)("inlineCode",{parentName:"li"},"obj")," with the relevant field name, or"),(0,o.kt)("li",{parentName:"ol"},"Calls a function on ",(0,o.kt)("inlineCode",{parentName:"li"},"obj")," with the relevant field name and passes the query arguments into that function")),(0,o.kt)("p",null,"So, in the example query above, the ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"title")," fields wouldn't need a resolver if the Post and Author objects retrieved from the backend already had those fields."),(0,o.kt)("h3",{id:"class-method-resolvers"},"Class method resolvers"),(0,o.kt)("p",null,"When returning an object or a class instance from a parent resolver, we are implicitly relying the GraphQL.js default resolver logic described above to execute the child resolvers. As such, class method resolvers have the following interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class Type {\n    fieldName(args, context, info) { result }\n}\n")),(0,o.kt)("h2",{id:"unions-and-interfaces"},"Unions and interfaces"),(0,o.kt)("p",null,"Unions and interfaces are great when you have fields that are in common between two types."),(0,o.kt)("p",null,"When you have a field in your schema that returns a union or interface type, you will need to specify an extra ",(0,o.kt)("inlineCode",{parentName:"p"},"__resolveType")," field in your resolver map, which tells the GraphQL executor which type the result is, out of the available options."),(0,o.kt)("p",null,"For example, if you have a ",(0,o.kt)("inlineCode",{parentName:"p"},"Vehicle")," interface type with members ",(0,o.kt)("inlineCode",{parentName:"p"},"Airplane")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Car"),":"),(0,o.kt)("p",null,"You could specify the schema like so"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"interface Vehicle {\n  maxSpeed: Int\n}\n\ntype Airplane implements Vehicle {\n  maxSpeed: Int\n  wingspan: Int\n}\n\ntype Car implements Vehicle {\n  maxSpeed: Int\n  licensePlate: String\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const resolverMap = {\n  Vehicle: {\n    __resolveType(obj, context, info){\n      if(obj.wingspan){\n        return 'Airplane';\n      }\n\n      if(obj.licensePlate){\n        return 'Car';\n      }\n\n      return null;\n    },\n  },\n};\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: Returning the type name as a string from ",(0,o.kt)("inlineCode",{parentName:"p"},"__resolveType")," is only supported starting with GraphQL.js 0.7.2. In previous versions, you had to get a reference using ",(0,o.kt)("inlineCode",{parentName:"p"},"info.schema.getType('Car')"),".")),(0,o.kt)("h2",{id:"api"},"API"),(0,o.kt)("p",null,"In addition to using a resolver map with ",(0,o.kt)("inlineCode",{parentName:"p"},"makeExecutableSchema"),", you can use it with any GraphQL.js schema by importing the following function from ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql-tools"),":"),(0,o.kt)("h3",{id:"addresolverstoschema-schema-resolvers-resolvervalidationoptions-inheritresolversfrominterfaces-"},"addResolversToSchema({ schema, resolvers, resolverValidationOptions?, inheritResolversFromInterfaces? })"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"addResolversToSchema")," takes an options object of ",(0,o.kt)("inlineCode",{parentName:"p"},"IAddResolveFunctionsToSchemaOptions")," and returns a new schema with resolvers attached to the relevant types."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'import { addResolversToSchema } from \'@graphql-tools/schema\';\n\nconst resolvers = {\n  RootQuery: {\n    author(obj, { name }, context){\n      console.log("RootQuery called with context " +\n        context + " to find " + name);\n      return Author.find({ name });\n    },\n  },\n};\n\nconst schemaWithResolvers = addResolversToSchema({ schema, resolvers });\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IAddResolveFunctionsToSchemaOptions")," object consists of several of the underlying properties used to configure ",(0,o.kt)("a",{parentName:"p",href:"/docs/generate-schema/#makeexecutableschemaoptions"},(0,o.kt)("inlineCode",{parentName:"a"},"makeExecutableSchema")," and described there"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface IAddResolveFunctionsToSchemaOptions {\n  schema: GraphQLSchema;\n  resolvers: IResolvers;\n  resolverValidationOptions?: IResolverValidationOptions;\n  inheritResolversFromInterfaces?: boolean;\n  updateResolversInPlace?: boolean;\n}\n")),(0,o.kt)("p",null,"Additionally, the ",(0,o.kt)("inlineCode",{parentName:"p"},"updateResolversInPlace")," property, when set to true, changes ",(0,o.kt)("inlineCode",{parentName:"p"},"addResolversToSchema")," behavior to modify the original schema in place without recreating it. By default, a new schema will be returned without modification of the original schema."),(0,o.kt)("h3",{id:"addschemalevelresolverschema-rootresolvefunction"},"addSchemaLevelResolver(schema, rootResolveFunction)"),(0,o.kt)("p",null,"Some operations, such as authentication, need to be done only once per query. Logically, these operations belong in a schema level resolver field resolver, but unfortunately GraphQL-JS does not let you define one. ",(0,o.kt)("inlineCode",{parentName:"p"},"addSchemaLevelResolver")," solves this by returning a new schema with the addition of a root resolve function."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You can check ",(0,o.kt)("a",{parentName:"p",href:"/docs/resolvers-composition"},"Resolvers Composition")," to compose resolvers with an authentication layer, and some checking operations etc.")))}c.isMDXComponent=!0}}]);