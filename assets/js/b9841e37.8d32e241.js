(self.webpackChunk_graphql_tools_website=self.webpackChunk_graphql_tools_website||[]).push([[9324],{5318:function(e,t,a){"use strict";a.d(t,{Zo:function(){return p},kt:function(){return u}});var n=a(7378);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=m(a),u=r,h=d["".concat(l,".").concat(u)]||d[u]||c[u]||i;return a?n.createElement(h,s(s({ref:t},p),{},{components:a})):n.createElement(h,s({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var m=2;m<i;m++)s[m]=a[m];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},1602:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return s},metadata:function(){return o},toc:function(){return l},default:function(){return p}});var n=a(9603),r=a(120),i=(a(7378),a(5318)),s={id:"schema-wrapping",title:"Schema wrapping",description:"Wrap schemas to automatically modify schemas, requests and results"},o={unversionedId:"schema-wrapping",id:"schema-wrapping",isDocsHomePage:!1,title:"Schema wrapping",description:"Wrap schemas to automatically modify schemas, requests and results",source:"@site/docs/schema-wrapping.md",sourceDirName:".",slug:"/schema-wrapping",permalink:"/docs/schema-wrapping",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/schema-wrapping.md",version:"current",frontMatter:{id:"schema-wrapping",title:"Schema wrapping",description:"Wrap schemas to automatically modify schemas, requests and results"},sidebar:"someSidebar",previous:{title:"Remote schemas",permalink:"/docs/remote-schemas"},next:{title:"Schema merging",permalink:"/docs/schema-merging"}},l=[{value:"Getting started",id:"getting-started",children:[]},{value:"Built-in transforms",id:"built-in-transforms",children:[{value:"Filtering",id:"filtering",children:[]},{value:"Renaming",id:"renaming",children:[]},{value:"Modifying",id:"modifying",children:[]},{value:"Grooming",id:"grooming",children:[]},{value:"Operational",id:"operational",children:[]}]},{value:"Custom transforms",id:"custom-transforms",children:[]},{value:"Subschema delegation",id:"subschema-delegation",children:[]}],m={toc:l};function p(e){var t=e.components,a=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Schema wrapping (",(0,i.kt)("inlineCode",{parentName:"p"},"@graphql-tools/wrap"),') creates a modified version of a schema that proxies, or "wraps", the original unmodified schema. This technique is particularly useful when the original schema ',(0,i.kt)("em",{parentName:"p"},"cannot")," be changed, such as with ",(0,i.kt)("a",{parentName:"p",href:"/docs/remote-schemas/"},"remote schemas"),"."),(0,i.kt)("p",null,'Schema wrapping works by creating a new "gateway" schema that simply delegates all operations to the original subschema. A series of ',(0,i.kt)("em",{parentName:"p"},"transforms")," are applied that may modify the shape of the gateway schema and all proxied operations; these operational transforms may modify an operation prior to delegation, or modify the subschema result prior to its return."),(0,i.kt)("p",null,"Note that ",(0,i.kt)("a",{parentName:"p",href:"/docs/stitch-combining-schemas"},"schema stitching")," is a ",(0,i.kt)("em",{parentName:"p"},"superset")," of the wrapping API. If you want to combine multiple services (with optional transforms) into one combined gateway schema, then you should use the ",(0,i.kt)("a",{parentName:"p",href:"/docs/stitch-combining-schemas"},"stitchSchemas")," method directly and allow it to handle all of the subservice wrappings."),(0,i.kt)("h2",{id:"getting-started"},"Getting started"),(0,i.kt)("p",null,"Let's consider changing the name of a type in a simple schema. In this example, we'd like to replace all instances of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Widget")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"NewWidget"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"# original subschema\ntype Widget {\n  id: ID!\n  name: String\n}\n\ntype Query {\n  widget: Widget\n}\n\n# wrapping gateway schema\ntype NewWidget {\n  id: ID!\n  name: String\n}\n\ntype Query {\n  widget: NewWidget\n}\n")),(0,i.kt)("p",null,"Upon delegation to the original subschema, we want the ",(0,i.kt)("inlineCode",{parentName:"p"},"NewWidget")," type to be mapped to the underlying ",(0,i.kt)("inlineCode",{parentName:"p"},"Widget")," type. At first glance, it might seem as though most queries will work the same as before:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"query {\n  widget {\n    id\n    name\n  }\n}\n")),(0,i.kt)("p",null,"Since the fields of the type have not changed, delegating to the original subschema is relatively easy here. However, the new name begins to matter when fragments and variables are used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"query {\n  widget {\n    id\n    ... on NewWidget {\n      name\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"NewWidget")," type does not exist in the original subschema, this fragment will not match anything there and gets filtered out during delegation. This problem is solved by operational transforms:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"transformRequest"),": a function that renames occurrences of ",(0,i.kt)("inlineCode",{parentName:"li"},"NewWidget -> Widget")," before delegating to the original subschema."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"transformResult"),": a function that conversely renames returned ",(0,i.kt)("inlineCode",{parentName:"li"},"__typename")," fields ",(0,i.kt)("inlineCode",{parentName:"li"},"Widget -> NewWidget")," in the final result.")),(0,i.kt)("p",null,"Conveniently, this task of renaming types is very common and there's a built-in transform available for it. Using the built-in transform with a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapSchema")," gets the job done:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { wrapSchema, RenameTypes } = require('@graphql-tools/wrap');\n\nconst typeNameMap = {\n  Widget: 'NewWidget',\n};\n\nconst schema = wrapSchema({\n  schema: originalSchema,\n  transforms: [new RenameTypes((name) => typeNameMap[name] || name)]\n});\n")),(0,i.kt)("h2",{id:"built-in-transforms"},"Built-in transforms"),(0,i.kt)("p",null,"These are ready-made classes implementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"Transform")," interface. They are intended to cover many common use cases, and they may also serve as examples of how to implement your own ",(0,i.kt)("a",{parentName:"p",href:"#custom-transforms"},"custom transforms"),"."),(0,i.kt)("h3",{id:"filtering"},"Filtering"),(0,i.kt)("p",null,"Filter transforms are constructed with a filter function that returns a boolean. The transform executes the filter on each schema element within its scope, and rejects elements that do not pass the filter."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.filtertypes"},(0,i.kt)("inlineCode",{parentName:"a"},"FilterTypes")),": filters all element types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.filterrootfields"},(0,i.kt)("inlineCode",{parentName:"a"},"FilterRootFields")),": filters fields on the root Query, Mutation, and Subscription objects."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.filterobjectfields"},(0,i.kt)("inlineCode",{parentName:"a"},"FilterObjectFields")),": filters fields of Object types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.filterobjectfielddirectives"},(0,i.kt)("inlineCode",{parentName:"a"},"FilterObjectFieldDirectives")),": filters Object field directives."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.filterinterfacefields"},(0,i.kt)("inlineCode",{parentName:"a"},"FilterInterfaceFields")),": filters fields of Interface types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.filterinputobjectfields"},(0,i.kt)("inlineCode",{parentName:"a"},"FilterInputObjectFields")),": filters input fields of InputObject types.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const schema = wrapSchema({\n  schema: originalSchema,\n  transforms: [\n    new FilterTypes((type) => true),\n    new FilterRootFields((operationName, fieldName, fieldConfig) => true),\n    new FilterObjectFields((typeName, fieldName, fieldConfig) => true),\n    new FilterObjectFieldDirectives((directiveName, directiveValue) => true),\n    new FilterInterfaceFields((typeName, fieldName, fieldConfig) => true),\n    new FilterInputObjectFields((typeName, fieldName, inputFieldConfig) => true),\n  ]\n});\n")),(0,i.kt)("h3",{id:"renaming"},"Renaming"),(0,i.kt)("p",null,"Renaming transforms are constructed with a renamer function that returns a string. The transform executes the renamer on each schema element within its scope, and applies the revised names to gateway schema elements. If a renamer returns ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),", the name will be left unchanged. Additional options may control whether built-in types and scalars are renamed, see linked API docs."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.renametypes"},(0,i.kt)("inlineCode",{parentName:"a"},"RenameTypes")),": renames all element types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.renameroottypes"},(0,i.kt)("inlineCode",{parentName:"a"},"RenameRootTypes")),": renames the root Query, Mutation, and Subscription types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.renamerootfields"},(0,i.kt)("inlineCode",{parentName:"a"},"RenameRootFields")),": renames fields on the root Query, Mutation, and Subscription objects."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.renameobjectfields"},(0,i.kt)("inlineCode",{parentName:"a"},"RenameObjectFields")),": renames fields of Object types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.renameinterfacefields"},(0,i.kt)("inlineCode",{parentName:"a"},"RenameInterfaceFields")),": renames fields of Interface types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.renameinputobjectfields"},(0,i.kt)("inlineCode",{parentName:"a"},"RenameInputObjectFields")),": renames input fields of InputObject types.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const schema = wrapSchema({\n  schema: originalSchema,\n  transforms: [\n    new RenameTypes((name) => `New${name}`),\n    new RenameRootTypes((name) => `New${name}`),\n    new RenameRootFields((operationName, fieldName, fieldConfig) => `new_${fieldName}`),\n    new RenameObjectFields((typeName, fieldName, fieldConfig) => `new_${fieldName}`),\n    new RenameInterfaceFields((typeName, fieldName, fieldConfig) => `new_${fieldName}`),\n    new RenameInputObjectFields((typeName, fieldName, inputFieldConfig) => `new_${fieldName}`),\n  ]\n});\n")),(0,i.kt)("h3",{id:"modifying"},"Modifying"),(0,i.kt)("p",null,"Modifying transforms allow element names and their definitions to be modified or omitted. They may filter, rename, and make other freeform modifications all at once. These transforms accept element transformer functions that may return one of several outcomes:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A modified version of the element config."),(0,i.kt)("li",{parentName:"ol"},"An array with a modified field name and new element config."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," to omit the element from the schema."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"undefined")," to leave the element unchanged.")),(0,i.kt)("p",null,"Available transforms include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.transformrootfields"},(0,i.kt)("inlineCode",{parentName:"a"},"TransformRootFields")),": redefines fields on the root Query, Mutation, and Subscription objects."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.transformobjectfields"},(0,i.kt)("inlineCode",{parentName:"a"},"TransformObjectFields")),": redefines fields of Object types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.transforminterfacefields"},(0,i.kt)("inlineCode",{parentName:"a"},"TransformInterfaceFields")),": redefines fields of Interface types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.transformcompositefields"},(0,i.kt)("inlineCode",{parentName:"a"},"TransformCompositeFields")),": redefines composite fields."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.transforminputobjectfields"},(0,i.kt)("inlineCode",{parentName:"a"},"TransformInputObjectFields")),": redefines fields of InputObject types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.transformenumvalues"},(0,i.kt)("inlineCode",{parentName:"a"},"TransformEnumValues")),": redefines values of Enum types.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const schema = wrapSchema({\n  schema: originalSchema,\n  transforms: [\n    new TransformRootFields((operationName, fieldName, fieldConfig) => fieldConfig),\n    new TransformObjectFields((typeName, fieldName, fieldConfig) => [`new_${fieldName}`, fieldConfig]),\n    new TransformInterfaceFields((typeName, fieldName, fieldConfig) => null),\n    new TransformCompositeFields((typeName, fieldName, fieldConfig) => undefined),\n    new TransformInputObjectFields((typeName, fieldName, inputFieldConfig) => [`new_${fieldName}`, inputFieldConfig]),\n    new TransformEnumValues((typeName, enumValue, enumValueConfig) => [`NEW_${enumValue}`, enumValueConfig]),\n  ]\n});\n")),(0,i.kt)("p",null,"These transforms accept an optional second node transformer function. When specified, the node transformer is called upon any element of the given kind in a request; transforming the result is possible by wrapping the element's resolver with the element transformer function (first argument)."),(0,i.kt)("h3",{id:"grooming"},"Grooming"),(0,i.kt)("p",null,"These transforms eliminate unwanted or unnecessary elements from a schema. These are configured in a variety of ways, so consult API documentation for specific options."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.pruneschema"},(0,i.kt)("inlineCode",{parentName:"a"},"PruneSchema")),": eliminates unreachable elements from the schema. This is generally useful to include ",(0,i.kt)("em",{parentName:"li"},"after")," a filter transform so that orphaned types and values are eliminated from the schema. Accepts ",(0,i.kt)("a",{parentName:"li",href:"/docs/api/modules/utils#pruneschema"},"pruneSchema")," options."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.removeobjectfielddeprecations"},(0,i.kt)("inlineCode",{parentName:"a"},"RemoveObjectFieldDeprecations")),": accepts a string or regex describing a deprecation to remove from the gateway schema. Fields matching this deprecation will be un-deprecated. Useful for normalizing ",(0,i.kt)("a",{parentName:"li",href:"/docs/stitch-type-merging#computed-fields"},"computed fields")," that are activated by the gateway wrapper."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.removeobjectfielddirectives"},(0,i.kt)("inlineCode",{parentName:"a"},"RemoveObjectFieldDirectives")),": removes object field directives that match a directive name and optional argument criteria."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.removeobjectfieldswithdeprecation"},(0,i.kt)("inlineCode",{parentName:"a"},"RemoveObjectFieldsWithDeprecation")),": removes object fields whose deprecation reason matches the provided string or regex."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/api/classes/wrap_src.removeobjectfieldswithdirective"},(0,i.kt)("inlineCode",{parentName:"a"},"RemoveObjectFieldsWithDirective")),": removes object fields with a schema directive matching a given name and optional argument criteria.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const schema = wrapSchema({\n  schema: originalSchema,\n  transforms: [\n    new PruneSchema(options),\n    new RemoveObjectFieldDeprecations(/^gateway access only/),\n    new RemoveObjectFieldDirectives('deprecated', { reason: /^gateway access only/ }),\n    new RemoveObjectFieldsWithDeprecation(/^gateway access only/),\n    new RemoveObjectFieldsWithDirective('deprecated', { reason: /^gateway access only/ }),\n  ]\n});\n")),(0,i.kt)("h3",{id:"operational"},"Operational"),(0,i.kt)("p",null,"It may be sometimes useful to add additional transforms to manually change an operation request or result when using ",(0,i.kt)("inlineCode",{parentName:"p"},"delegateToSchema"),". Common use cases may be move selections around or to wrap them. The following built-in transforms may be useful in those cases."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ExtractField({ from: Array<string>, to: Array<string> })")," move selection at ",(0,i.kt)("inlineCode",{parentName:"li"},"from")," path to ",(0,i.kt)("inlineCode",{parentName:"li"},"to")," path."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"WrapQuery(path: Array<string>, wrapper: QueryWrapper, extractor: (result: any) => any)")," wrap a selection at ",(0,i.kt)("inlineCode",{parentName:"li"},"path")," using function ",(0,i.kt)("inlineCode",{parentName:"li"},"wrapper"),". Apply ",(0,i.kt)("inlineCode",{parentName:"li"},"extractor")," at the same path to get the result. This is used to get a result nested inside other result.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"transforms: [\n  // Wrap document takes a subtree as an AST node\n  new WrapQuery(\n    // path at which to apply wrapping and extracting\n    ['userById'],\n    (subtree: SelectionSetNode) => ({\n      // we create a wrapping AST Field\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        // that field is `address`\n        value: 'address',\n      },\n      // Inside the field selection\n      selectionSet: subtree,\n    }),\n    // how to process the data result at path\n    result => result && result.address,\n  ),\n],\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"WrapQuery")," can also be used to expand multiple top level query fields"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"transforms: [\n  // Wrap document takes a subtree as an AST node\n  new WrapQuery(\n    // path at which to apply wrapping and extracting\n    ['userById'],\n    (subtree: SelectionSetNode) => {\n      const newSelectionSet = {\n        kind: Kind.SELECTION_SET,\n        selections: subtree.selections.map(selection => {\n          // just append fragments, not interesting for this\n          // test\n          if (selection.kind === Kind.INLINE_FRAGMENT ||\n            selection.kind === Kind.FRAGMENT_SPREAD) {\n            return selection;\n          }\n          // prepend `address` to name and camelCase\n          const oldFieldName = selection.name.value;\n          return {\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: 'address' +\n                oldFieldName.charAt(0).toUpperCase() +\n                oldFieldName.slice(1)\n            }\n          };\n        })\n      };\n      return newSelectionSet;\n    },\n    // how to process the data result at path\n    result => ({\n      streetAddress: result.addressStreetAddress,\n      zip: result.addressZip\n    })\n")),(0,i.kt)("h2",{id:"custom-transforms"},"Custom transforms"),(0,i.kt)("p",null,"Custom transforms are fairly straightforward to write. They are simply objects with up to three methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transformSchema"),": receives the original subschema and applies modifications to it, returning a modified wrapper (proxy) schema. This method runs once while initially wrapping the subschema."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transformRequest"),": receives each request made to the wrapped schema. The shape of a request matches the wrapper schema, and must be returned in a shape that matches the original subschema."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transformResult"),": receives each result returned from the original subschema. The shape of the result matches the original subschema, and must be returned in a shape that matches the wrapper schema.")),(0,i.kt)("p",null,"The complete transform object API is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export interface Transform<T = Record<string, any>> {\n  transformSchema?: SchemaTransform;\n  transformRequest?: RequestTransform<T>;\n  transformResult?: ResultTransform<T>;\n}\n\nexport type SchemaTransform = (\n  originalWrappingSchema: GraphQLSchema,\n  subschemaConfig: SubschemaConfig,\n  transformedSchema?: GraphQLSchema\n) => GraphQLSchema;\n\nexport type RequestTransform<T = Record<string, any>> = (\n  originalRequest: Request,\n  delegationContext: DelegationContext,\n  transformationContext: T\n) => Request;\n\nexport type ResultTransform<T = Record<string, any>> = (\n  originalResult: ExecutionResult,\n  delegationContext: DelegationContext,\n  transformationContext: T\n) => ExecutionResult;\n\ntype Request = {\n  document: DocumentNode;\n  variables: Record<string, any>;\n  extensions?: Record<string, any>;\n};\n")),(0,i.kt)("p",null,"A simple transform that removes types, fields, and arguments prefixed by an underscore might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { wrapSchema } from '@graphql-tools/wrap';\nimport { filterSchema, pruneSchema } from '@graphql-tools/utils';\n\nclass RemovePrivateElementsTransform {\n  transformSchema(originalWrappingSchema) {\n    const isPublicName = (name) => !name.startsWith('_');\n\n    return pruneSchema(filterSchema({\n      schema: originalWrappingSchema,\n      typeFilter: (typeName) => isPublicName(typeName),\n      rootFieldFilter: (operationName, fieldName) => isPublicName(fieldName),\n      fieldFilter: (typeName, fieldName) => isPublicName(fieldName),\n      argumentFilter: (typeName, fieldName, argName) => isPublicName(argName),\n    }));\n  }\n\n  // no need for operational transforms\n}\n\nconst schema = wrapSchema({\n  schema: myRemoteSchema,\n  transforms: [new RemovePrivateElementsTransform()]\n});\n")),(0,i.kt)("h2",{id:"subschema-delegation"},"Subschema delegation"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapSchema")," method will produce a new schema with all queued ",(0,i.kt)("inlineCode",{parentName:"p"},"transformSchema")," methods applied. Delegating resolvers are automatically generated to map from new schema root fields to old schema root fields. These resolvers should be sufficient for most common case so you don't have to implement your own."),(0,i.kt)("p",null,"Delegating resolvers will apply all operation transforms defined by the wrapper's ",(0,i.kt)("inlineCode",{parentName:"p"},"Transform")," objects. Each provided ",(0,i.kt)("inlineCode",{parentName:"p"},"transformRequest")," functions will be applies in reverse order, until the request matches the original schema. The ",(0,i.kt)("inlineCode",{parentName:"p"},"transformResult")," functions will be applied in the opposite order until the result matches the final gateway schema."),(0,i.kt)("p",null,"In advanced cases, transforms may wish to create additional delegating root resolvers (for example, when hoisting a field into a root type). This is also possible. The wrapping schema is actually generated twice -- the first run results in a possibly non-executable version, while the second execution also includes the result of the first one within the ",(0,i.kt)("inlineCode",{parentName:"p"},"transformedSchema")," argument so that an executable version with any new proxying resolvers can be created."),(0,i.kt)("p",null,"Remote schemas can also be wrapped! In fact, this is the primary use case. See documentation regarding ",(0,i.kt)("a",{parentName:"p",href:"/docs/remote-schemas/"},"remote schemas")," for further details about remote schemas. Note that as explained there, when wrapping remote schemas, you will be wrapping a subschema config object, and the array of transforms should be defined on that object rather than as a second argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"wrapSchema"),"."))}p.isMDXComponent=!0}}]);